// src/features/product/components/ProductChat/components/MobileChatContainer.tsx - VERSION CORRIG√âE STRIPE FLOW
'use client';

import React, { useEffect, useRef, useState, useCallback } from 'react';
import { ArrowLeft, Star, Mic, Send, ShoppingBag, Volume2, MicOff } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import { useLayoutContext } from '@/core/context/LayoutContext';
import { useChatStore } from '@/stores/chatStore';
import { ConversationProvider } from '@/hooks/useConversationContext';
import { BictorysPaymentModal } from '@/components/payment/BictorysPaymentModal';
import { StripePaymentModal } from '@/components/payment/StripePaymentModal';
import { WelcomeMessageService } from '@/lib/services/WelcomeMessageService';
import { productStatsService } from '@/lib/services/product-stats.service';
import { testimonialsService } from '@/lib/services/testimonials.service';
import { useSpeechRecognition } from '@/lib/services/SpeechRecognitionService';
import TypingIndicator from './TypingIndicator';
import ChatMessage from './ChatMessage';
import QuantitySelector from './QuantitySelector';
import type { PaymentProvider } from '@/types/order';
import type { ProductData } from '@/types/chat';
import type { ChatMessage as ChatMessageType, ConversationStep } from '@/types/chat';
import type { RealTimeStats } from '@/types/product';
import { supabase } from '@/lib/supabase';
import { OptimizedChatService } from '@/lib/services/OptimizedChatService';

interface MobileChatContainerProps {
  product: ProductData;
  storeId: string;
  onBackClick: () => void;
}

// üé§ COMPOSANT INPUT VOCAL AM√âLIOR√â
const VoiceEnabledInput: React.FC<{
  value: string;
  onChange: (value: string) => void;
  onSend: () => void;
  disabled: boolean;
  placeholder: string;
}> = ({ value, onChange, onSend, disabled, placeholder }) => {
  const {
    transcript,
    isListening,
    isSupported,
    error,
    startListening,
    stopListening,
    resetTranscript
  } = useSpeechRecognition();

  const [showVoiceMode, setShowVoiceMode] = useState(false);

  // Synchroniser le transcript avec l'input
  useEffect(() => {
    if (transcript && !isListening) {
      onChange(transcript);
      resetTranscript();
      setShowVoiceMode(false);
    }
  }, [transcript, isListening, onChange, resetTranscript]);

  const handleVoiceToggle = async () => {
    if (!isSupported) {
      alert('Reconnaissance vocale non support√©e sur ce navigateur');
      return;
    }

    if (isListening) {
      stopListening();
      setShowVoiceMode(false);
    } else {
      try {
        setShowVoiceMode(true);
        await startListening({
          language: 'fr-FR',
          continuous: false,
          interimResults: true
        });
      } catch (err) {
        console.error('Erreur reconnaissance vocale:', err);
        setShowVoiceMode(false);
      }
    }
  };

  const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      onSend();
    }
  };

  return (
    <div className="relative">
      {/* Mode vocal actif */}
      {showVoiceMode && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: 20 }}
          className="absolute bottom-full left-0 right-0 mb-2 p-3 bg-[#FF7E93] rounded-xl text-white text-center"
        >
          <div className="flex items-center justify-center gap-2 mb-1">
            <Volume2 className="w-4 h-4 animate-pulse" />
            <span className="text-sm font-medium">
              {isListening ? 'Je vous √©coute...' : 'Activez votre micro'}
            </span>
          </div>
          {transcript && (
            <div className="text-xs opacity-90">"{transcript}"</div>
          )}
          {error && (
            <div className="text-xs text-red-200 mt-1">{error}</div>
          )}
        </motion.div>
      )}

      {/* Champ de saisie style ancien design */}
      <div className="relative flex items-center">
        <input
          type="text"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          className="w-full px-4 py-2 bg-[#F0F2F5] text-gray-800 rounded-full pr-24 focus:outline-none disabled:opacity-50 disabled:cursor-not-allowed"
          disabled={disabled}
          maxLength={500}
        />
        <div className="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-2">
          {/* Bouton micro */}
          <button
            type="button"
            onClick={handleVoiceToggle}
            disabled={disabled || !isSupported}
            className={`p-2 rounded-full transition-colors ${
              isListening 
                ? 'bg-red-500 text-white animate-pulse' 
                : isSupported && !disabled
                  ? 'text-gray-500 hover:text-[#FF7E93] hover:bg-gray-50'
                  : 'text-gray-400 cursor-not-allowed'
            }`}
            title={
              !isSupported 
                ? 'Reconnaissance vocale non support√©e' 
                : isListening 
                  ? 'Arr√™ter l\'√©coute'
                  : 'Reconnaissance vocale'
            }
          >
            {isListening ? <MicOff className="w-5 h-5" /> : <Mic className="w-5 h-5" />}
          </button>
          
          {/* Bouton envoi */}
          <button
            type="button"
            onClick={onSend}
            disabled={!value.trim() || disabled}
            className={`p-2 transition-colors ${
              value.trim() && !disabled
                ? 'text-[#FF7E93] hover:text-[#132D5D]' 
                : 'text-gray-400 cursor-not-allowed'
            }`}
            title={disabled ? 'Traitement en cours...' : 'Envoyer le message'}
          >
            {disabled ? (
              <div className="w-5 h-5 border-2 border-gray-300 border-t-[#FF7E93] rounded-full animate-spin" />
            ) : (
              <Send className="w-5 h-5" />
            )}
          </button>
        </div>
      </div>
    </div>
  );
};

const MobileChatContainer: React.FC<MobileChatContainerProps> = ({
  product,
  storeId,
  onBackClick
}) => {
  const chatRef = useRef<HTMLDivElement>(null);
  const [inputMessage, setInputMessage] = useState('');
  const { setHideHeaderGroup } = useLayoutContext();
  const [stripeModalOpen, setStripeModalOpen] = useState(false);
  const [stripeModalData, setStripeModalData] = useState<{
    amount: number;
    orderId: string;
  } | null>(null);
  const [showTyping, setShowTyping] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  
  // ‚úÖ √âtats locaux simplifi√©s pour √©viter les boucles
  const [initializationStarted, setInitializationStarted] = useState(false);
  const [welcomeMessageSent, setWelcomeMessageSent] = useState(false);
  
  const [stats, setStats] = useState<RealTimeStats>({
    viewsCount: 0,
    salesCount: 0,
    reviewsCount: 0
  });
  const [rating, setRating] = useState(product.stats?.satisfaction || 5);

  // ‚úÖ Service d'accueil corrig√©
  const welcomeService = WelcomeMessageService.getInstance();

  // ‚úÖ Utilisation s√©lective du store pour √©viter les re-renders
  const store = useChatStore();
  const {
    messages = [],
    orderData = {},
    sessionId = '',
    isTyping = false,
    payment = {
      status: 'idle' as const,
      error: null,
      clientSecret: null
    },
    paymentModal = {
      isOpen: false,
      iframeUrl: '',
      provider: undefined
    },
    initializeSession,
    addMessage,
    updateTypingStatus,
    setPaymentModal = () => {},
    cleanup,
    updateOrderData,
    currentStep = null,
    flags = {
      hasError: false,
      stockReserved: false,
      orderCompleted: false,
      paymentInitiated: false,
      isInitialized: false
    }
  } = store;

  // ‚úÖ NOUVEAU : √âtat du panier d√©riv√© des messages et orderData
  const [cartInfo, setCartInfo] = useState({
    hasItems: false,
    itemsCount: 0,
    totalAmount: 0,
    productName: product.name
  });

  // ‚úÖ CORRECTION MAJEURE : Fonction de d√©tection du panier pour mobile
  const detectCartFromMessages = useCallback(() => {
    console.log('üõí [MOBILE] D√âTECTION PANIER:', { 
      orderData, 
      messagesLength: messages?.length,
      currentStep,
      flags
    });

    let newCartInfo = {
      hasItems: false,
      itemsCount: 0,
      totalAmount: 0,
      productName: product.name
    };

    // PRIORIT√â 1: orderData direct (plus fiable)
    if (orderData.quantity && orderData.quantity > 0) {
      const totalAmount = (orderData.quantity || 1) * product.price;
      
      newCartInfo = {
        hasItems: true,
        itemsCount: orderData.quantity,
        totalAmount: totalAmount,
        productName: product.name
      };
      
      console.log('‚úÖ [MOBILE] Cart found in orderData:', newCartInfo);
      return newCartInfo;
    }

    // PRIORIT√â 2: Analyser les messages pour d√©tecter une commande
    if (messages && messages.length > 0) {
      const hasCommanderMessages = messages.some(msg => {
        const content = typeof msg.content === 'string' ? msg.content : String(msg.content || '');
        return content.includes('C\'est not√© ! Vous commandez') ||
               content.includes('exemplaire') ||
               content.includes('Prix total') ||
               (msg.metadata?.flags?.expressMode && msg.metadata?.flags?.quantitySelection);
      });

      if (hasCommanderMessages) {
        let quantity = 1;
        
        // Analyser les messages de la fin vers le d√©but pour trouver la quantit√©
        for (const msg of [...messages].reverse()) {
          const content = typeof msg.content === 'string' ? msg.content : String(msg.content || '');
          
          if (content.includes('exemplaire')) {
            const qtyMatch = content.match(/(\d+)\s*exemplaire/);
            if (qtyMatch) quantity = parseInt(qtyMatch[1]);
            
            // Essayer d'extraire le prix total du message
            const priceMatch = content.match(/(\d+(?:[\s,]\d{3})*)\s*FCFA/);
            if (priceMatch) {
              const totalAmount = parseInt(priceMatch[1].replace(/[\s,]/g, ''));
              
              newCartInfo = {
                hasItems: true,
                itemsCount: quantity,
                totalAmount: totalAmount,
                productName: product.name
              };
              
              console.log('‚úÖ [MOBILE] Cart found in messages:', newCartInfo);
              break;
            } else {
              // Calculer le total bas√© sur le prix du produit et la quantit√©
              newCartInfo = {
                hasItems: true,
                itemsCount: quantity,
                totalAmount: quantity * product.price,
                productName: product.name
              };
              
              console.log('‚úÖ [MOBILE] Cart calculated from quantity:', newCartInfo);
              break;
            }
          }
        }
      }
    }

    console.log('üìä [MOBILE] Final cart info:', newCartInfo);
    return newCartInfo;
  }, [orderData, messages, currentStep, flags, product.name, product.price]);

  // ‚úÖ EFFET pour mettre √† jour le panier quand les messages ou orderData changent
  useEffect(() => {
    const newCartInfo = detectCartFromMessages();
    
    // Seulement mettre √† jour si quelque chose a chang√©
    if (JSON.stringify(newCartInfo) !== JSON.stringify(cartInfo)) {
      console.log('üîÑ [MOBILE] Updating cart info:', newCartInfo);
      setCartInfo(newCartInfo);
    }
  }, [detectCartFromMessages, cartInfo]);

  // ‚úÖ INITIALISATION CORRIG√âE avec message d'accueil correct
  useEffect(() => {
    if (!product?.id || initializationStarted || welcomeMessageSent) {
      return;
    }

    const initializeChat = async () => {
      try {
        console.log('üì± Initializing mobile chat session:', { 
          productId: product.id, 
          storeId,
          initializationStarted,
          welcomeMessageSent,
          existingMessages: messages.length
        });
        
        setInitializationStarted(true);

        // V√©rifier si des messages existent d√©j√†
        if (messages.length > 0) {
          console.log('üìù Mobile chat already has messages, skipping initialization');
          setWelcomeMessageSent(true);
          return;
        }

        // Initialiser la session
        if (initializeSession) {
          const newSessionId = sessionId || `mobile_${product.id}_${Date.now()}`;
          initializeSession(product.id, storeId, newSessionId);
        }
        
        // ‚úÖ NOUVEAU : S√©quence r√©aliste avec typing indicator et message CORRECT
        setTimeout(() => {
          // V√©rifier encore une fois qu'aucun message n'a √©t√© ajout√©
          const currentState = useChatStore.getState();
          
          if (currentState.messages.length === 0 && !welcomeMessageSent) {
            // ‚úÖ √âTAPE 1: Afficher "Rose √©crit..." pendant 2 secondes
            console.log('üìù Showing typing indicator...');
            setShowTyping(true);
            updateTypingStatus(true);
            
            // ‚úÖ √âTAPE 2: Apr√®s 2 secondes, afficher le MESSAGE CORRECT
            setTimeout(() => {
              setShowTyping(false);
              updateTypingStatus(false);
              
              // ‚úÖ UTILISER LE SERVICE CORRECT POUR MOBILE
              const welcomeMessage = welcomeService.generateMobileWelcomeMessage(
                product.name,
                sessionId,
                product.id,
                product.price
              );
              
              console.log('üìù Adding CORRECT welcome message to mobile chat');
              addMessage(welcomeMessage);
              setWelcomeMessageSent(true);
            }, 2000); // ‚úÖ 2 secondes de typing indicator
          } else {
            console.log('‚ö†Ô∏è Mobile: Welcome message skipped - messages exist or already sent');
            setWelcomeMessageSent(true);
          }
        }, 800); // ‚úÖ D√©lai initial avant typing
        
      } catch (error) {
        console.error('‚ùå Error initializing mobile chat:', error);
        setInitializationStarted(true);
        setWelcomeMessageSent(true);
      }
    };

    initializeChat();
  }, [product.id, storeId, initializationStarted, welcomeMessageSent, updateTypingStatus, addMessage, welcomeService, sessionId]);

  // ‚úÖ Header management
  useEffect(() => {
    setHideHeaderGroup(true);
    return () => setHideHeaderGroup(false);
  }, []);

  // ‚úÖ STATS LOADING AVEC TESTIMONIALS R√âELS
  useEffect(() => {
    let isSubscribed = true;

    const initializeStats = async () => {
      try {
        // ‚úÖ CHARGER LES VRAIES DONN√âES depuis testimonials
        const [productStats, testimonialsCount, averageRating] = await Promise.all([
          productStatsService.getProductStats(product.id),
          testimonialsService.getTestimonialsCountByProduct(product.id),
          testimonialsService.getAverageRating(product.id)
        ]);
        
        if (!isSubscribed) return;

        // ‚úÖ UTILISER LES VRAIES DONN√âES D'AVIS
        setStats({
          viewsCount: productStats.currentViewers || 1,
          salesCount: productStats.sold || 0,
          reviewsCount: testimonialsCount || 0  // ‚úÖ VRAIE DONN√âE des testimonials
        });

        // ‚úÖ UTILISER LA VRAIE NOTE MOYENNE
        if (averageRating > 0) {
          setRating(averageRating);
        }

        console.log('üìä Real stats loaded:', {
          viewsCount: productStats.currentViewers || 1,
          salesCount: productStats.sold || 0,
          reviewsCount: testimonialsCount || 0,
          rating: averageRating || rating
        });

      } catch (error) {
        console.error('Error loading stats:', error);
        // ‚úÖ FALLBACK : Essayer de charger depuis la base directement
        try {
          const { data: testimonials } = await supabase
            .from('testimonials')
            .select('rating')
            .eq('product_id', product.id);

          if (isSubscribed && testimonials) {
            const count = testimonials.length;
            const avgRating = testimonials.length > 0 
              ? testimonials.reduce((sum, t) => sum + t.rating, 0) / testimonials.length
              : 5;

            setStats(prev => ({
              ...prev,
              reviewsCount: count
            }));
            
            if (avgRating > 0) {
              setRating(avgRating);
            }
          }
        } catch (fallbackError) {
          console.error('Fallback stats loading failed:', fallbackError);
          // Utiliser stats par d√©faut r√©alistes
          if (isSubscribed) {
            setStats({
              viewsCount: Math.floor(Math.random() * 8) + 2,
              salesCount: Math.floor(Math.random() * 25) + 10,
              reviewsCount: Math.floor(Math.random() * 12) + 5
            });
          }
        }
      }
    };

    if (product.id) {
      initializeStats();
      // Incr√©menter les vues
      productStatsService.incrementViewCount(product.id);
    }

    return () => {
      isSubscribed = false;
    };
  }, [product.id]);

  // ‚úÖ Auto-scroll optimis√©
  useEffect(() => {
    if (chatRef.current && messages.length > 0) {
      const scrollToBottom = () => {
        chatRef.current?.scrollTo({
          top: chatRef.current.scrollHeight,
          behavior: 'smooth'
        });
      };
      
      const timeoutId = setTimeout(scrollToBottom, 100);
      return () => clearTimeout(timeoutId);
    }
  }, [messages.length, showTyping]);

  // ‚úÖ GESTION INTELLIGENTE DES MESSAGES STANDARDS AVEC DONN√âES DB
  const handleStandardMessages = useCallback(async (content: string): Promise<ChatMessageType> => {
    console.log('üìù Processing standard message:', content);

    // ‚úÖ UTILISER LE SERVICE D'ACCUEIL POUR LES R√âPONSES STANDARD
    if (welcomeService.isWelcomeResponse(content)) {
      return await welcomeService.handleWelcomeButtonResponse(content, product.id, product.name);
    }

    // ‚úÖ BOUTON : "Comment y jouer ?"
    if (content.includes('Comment y jouer') || content.includes('Comment jouer')) {
      try {
        const { data: productData, error } = await supabase
          .from('products')
          .select('game_rules, name')
          .eq('id', product.id)
          .maybeSingle();

        let gameRules = '';
        
        if (error || !productData || !productData.game_rules?.trim()) {
          gameRules = `üéÆ **Comment jouer au jeu ${product.name} :**

üìã **R√®gles simples :**
‚Ä¢ M√©langez les cartes
‚Ä¢ Chaque joueur tire une carte √† tour de r√¥le
‚Ä¢ Lisez la question/d√©fi √† voix haute
‚Ä¢ R√©pondez de mani√®re authentique
‚Ä¢ √âcoutez et √©changez avec bienveillance

‚è∞ **Dur√©e :** 30-60 minutes
üë• **Participants :** 2 personnes minimum
‚ú® **Objectif :** Cr√©er des conversations m√©morables

üìû **Pour les r√®gles d√©taill√©es :**
WhatsApp : +221 78 136 27 28`;
        } else {
          gameRules = `üéÆ **Comment jouer au jeu ${productData.name} :**

${productData.game_rules}

üéØ **Pr√™t(e) √† vivre cette exp√©rience ?**`;
        }

        return {
          type: 'assistant',
          content: gameRules,
          choices: [
            'Je veux l\'acheter maintenant',
            'C\'est pour qui ?',
            'Quels sont les b√©n√©fices ?',
            'Voir les avis clients'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: 'game_rules_shown' as ConversationStep,
            flags: { gameRulesShown: true }
          },
          timestamp: new Date().toISOString()
        };
      } catch (error) {
        console.error('‚ùå Error fetching game rules:', error);
      }
    }

    // ‚úÖ BOUTON : "C'est pour qui ?"
    if (content.includes('C\'est pour qui') || content.includes('pour qui')) {
      try {
        const { data: productData, error } = await supabase
          .from('products')
          .select('target_audience, name')
          .eq('id', product.id)
          .maybeSingle();

        let targetInfo = '';
        
        if (error || !productData || !productData.target_audience) {
          targetInfo = `üë• **Le jeu ${product.name} est parfait pour :**

üíë **Les couples** qui veulent renforcer leur complicit√©
üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **Les familles** qui cherchent √† mieux se conna√Ætre
üë´ **Les amis** qui veulent approfondir leur amiti√©
üëî **Les coll√®gues** pour am√©liorer la coh√©sion d'√©quipe

‚ú® **√Çge recommand√© :** √Ä partir de 16 ans
üéØ **Id√©al pour :** Tous ceux qui veulent des relations plus authentiques`;
        } else {
          const audience = Array.isArray(productData.target_audience) 
            ? productData.target_audience.join(', ')
            : productData.target_audience;
          
          targetInfo = `üë• **Le jeu ${productData.name} est parfait pour :**

${audience}

‚ú® **Une exp√©rience adapt√©e √† tous ceux qui veulent des relations plus profondes et authentiques.**`;
        }

        return {
          type: 'assistant',
          content: targetInfo,
          choices: [
            'Je veux l\'acheter maintenant',
            'Comment y jouer ?',
            'Quels sont les b√©n√©fices ?',
            'Voir les t√©moignages'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: 'target_audience_shown' as ConversationStep,
            flags: { targetAudienceShown: true }
          },
          timestamp: new Date().toISOString()
        };
      } catch (error) {
        console.error('‚ùå Error fetching target audience:', error);
      }
    }

    // ‚úÖ BOUTON : "Quels sont les b√©n√©fices ?"
    if (content.includes('Quels sont les b√©n√©fices') || content.includes('b√©n√©fices')) {
      try {
        const { data: productData, error } = await supabase
          .from('products')
          .select('benefits, name')
          .eq('id', product.id)
          .maybeSingle();

        let benefits = '';
        
        if (error || !productData || !productData.benefits) {
          benefits = `üíù **Les b√©n√©fices du jeu ${product.name} :**

üî• **Renforce la complicit√©** entre vous et vos proches
üí¨ **Facilite la communication** sur des sujets importants
‚ú® **Cr√©e des souvenirs m√©morables** et des moments d'intimit√©
üåü **D√©veloppe l'empathie** et la compr√©hension mutuelle
‚ù§Ô∏è **Approfondit les relations** de mani√®re naturelle et amusante

üéØ **R√©sultat :** Des liens plus forts et une meilleure connaissance de l'autre`;
        } else {
          const benefitsList = Array.isArray(productData.benefits) 
            ? productData.benefits.join('\n‚Ä¢ ')
            : productData.benefits;
          
          benefits = `üíù **Les b√©n√©fices du jeu ${productData.name} :**

‚Ä¢ ${benefitsList}

üéØ **Une exp√©rience transformatrice pour vos relations !**`;
        }

        return {
          type: 'assistant',
          content: benefits,
          choices: [
            'Je veux l\'acheter maintenant',
            'Comment y jouer ?',
            'C\'est pour qui ?',
            'Voir les t√©moignages'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: 'benefits_shown' as ConversationStep,
            flags: { benefitsShown: true }
          },
          timestamp: new Date().toISOString()
        };
      } catch (error) {
        console.error('‚ùå Error fetching benefits:', error);
      }
    }

    // ‚úÖ BOUTON : "Quels sont les avis clients ?"
    if (content.includes('avis clients') || content.includes('t√©moignages') || content.includes('avis')) {
      try {
        const { data: testimonials, error } = await supabase
          .from('testimonials')
          .select('*')
          .eq('product_id', product.id)
          .eq('is_approved', true)
          .order('created_at', { ascending: false })
          .limit(3);

        let testimonialsContent = '';
        
        if (error || !testimonials || testimonials.length === 0) {
          testimonialsContent = `‚≠ê **Ce que disent nos clients sur ${product.name} :**

Nous collectons actuellement les premiers t√©moignages de nos clients.

üîÑ **En attendant, d√©couvrez pourquoi nos jeux fonctionnent :**
‚Ä¢ M√©thode test√©e et approuv√©e
‚Ä¢ Conception bas√©e sur la psychologie des relations
‚Ä¢ D√©j√† des centaines de couples/familles transform√©s

üìû **Questions ? Contactez-nous :**
WhatsApp : +221 78 136 27 28`;
        } else {
          const testimonialTexts = testimonials.map(t => {
            const stars = '‚≠ê'.repeat(t.rating);
            return `${stars} **${t.author_name || 'Client'}** ${t.author_location ? `(${t.author_location})` : ''}\n"${t.content}"`;
          }).join('\n\n');
          
          testimonialsContent = `‚≠ê **Ce que disent nos clients sur ${product.name} :**

${testimonialTexts}

üí¨ **Et vous, pr√™t(e) √† vivre cette exp√©rience ?**`;
        }

        return {
          type: 'assistant',
          content: testimonialsContent,
          choices: [
            'Je veux l\'acheter maintenant',
            'Comment y jouer ?',
            'C\'est pour qui ?',
            'Quels sont les b√©n√©fices ?'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: 'testimonials_shown' as ConversationStep,
            flags: { testimonialsShown: true }
          },
          timestamp: new Date().toISOString()
        };
      } catch (error) {
        console.error('‚ùå Error fetching testimonials:', error);
      }
    }

    // R√©ponse par d√©faut
    return {
      type: 'assistant',
      content: `Merci pour votre message ! Comment puis-je vous aider davantage avec le jeu **${product.name}** ?`,
      choices: [
        'Je veux l\'acheter maintenant',
        'J\'ai des questions √† poser',
        'Je veux en savoir plus'
      ],
      assistant: {
        name: 'Rose',
        title: 'Assistante d\'achat'
      },
      metadata: {
        nextStep: 'initial_engagement' as ConversationStep
      },
      timestamp: new Date().toISOString()
    };
  }, [product.id, product.name, welcomeService]);

  // ‚úÖ Cr√©er un message d'erreur
  const createErrorResponse = useCallback((errorText: string): ChatMessageType => ({
    type: 'assistant',
    content: `üòî **${errorText}**

Voulez-vous r√©essayer ou contacter notre support ?`,
    choices: ['üîÑ R√©essayer', 'üìû Contacter le support'],
    assistant: {
      name: 'Rose',
      title: 'Assistante d\'achat'
    },
    metadata: {
      nextStep: 'error_recovery' as ConversationStep,
      flags: { hasError: true }
    },
    timestamp: new Date().toISOString()
  }), []);

  // ‚úÖ CORRECTION MAJEURE: Envoi de message avec protection Stripe
  const sendMessage = useCallback(async (content: string) => {
    if (isProcessing) {
      console.log('‚è≥ Already processing a message, ignoring');
      return;
    }

    try {
      console.log('üì± Processing mobile message:', { content: content.substring(0, 50) });
      
      // ‚úÖ NOUVEAU: G√©rer l'ouverture du modal Stripe
      if (content.startsWith('STRIPE_MODAL_OPEN:')) {
        const amount = parseInt(content.split(':')[1]);
        const orderId = `STRIPE-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
        
        setStripeModalData({ amount, orderId });
        setStripeModalOpen(true);
        return;
      }
      
      // Ajouter le message utilisateur imm√©diatement
      const userMessage: ChatMessageType = {
        type: 'user',
        content,
        timestamp: new Date().toISOString(),
        metadata: {
          flags: {
            isButtonChoice: true,
            preventAIIntervention: true
          }
        }
      };
      
      addMessage(userMessage);

      let response: ChatMessageType;
      
      // ‚úÖ CORRECTION MAJEURE: Utiliser directement OptimizedChatService comme sur desktop
      try {
        // Utilisation de l'API chat pour coh√©rence
        const apiResponse = await fetch('/api/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message: content,
            productId: product.id,
            currentStep: currentStep || 'initial',
            orderData: orderData || {},
            sessionId: sessionId || `${product.id}_${Date.now()}`,
            storeId: storeId || 'default'
          }),
        });

        if (!apiResponse.ok) {
          throw new Error(`Mobile API error ${apiResponse.status}`);
        }

        const aiResponse = await apiResponse.json();
        console.log('‚úÖ Mobile: API response received');

        response = {
          type: 'assistant',
          content: aiResponse.message || "Je suis l√† pour vous aider !",
          choices: aiResponse.choices || ["Je veux l'acheter maintenant", "J'ai des questions √† poser"],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: aiResponse.nextStep || currentStep,
            orderData: aiResponse.orderData,
            flags: aiResponse.flags || {}
          },
          timestamp: new Date().toISOString()
        };

      } catch (apiError) {
        console.error('‚ùå Mobile: API call failed, falling back to direct service:', apiError);
        
        // ‚úÖ FALLBACK: Utiliser directement OptimizedChatService
        const optimizedService = OptimizedChatService.getInstance();
        response = await optimizedService.processMessage(
          sessionId || `${product.id}_${Date.now()}`,
          content,
          currentStep || 'initial',
          product.id,
          product.name
        );
      }
      
      // D√©lai pour l'animation
      setTimeout(() => {
        console.log('‚úÖ Mobile: Response generated');
        addMessage(response);
        
        if (response.metadata?.orderData) {
          updateOrderData(response.metadata.orderData);
        }
      }, 800);

    } catch (err) {
      console.error('‚ùå Mobile: Error in sendMessage:', err);
      
      setTimeout(() => {
        const errorMessage = createErrorResponse(`Une erreur est survenue: ${err instanceof Error ? err.message : 'Erreur inconnue'}`);
        addMessage(errorMessage);
      }, 500);
    }
  }, [isProcessing, product.id, currentStep, orderData, sessionId, storeId, addMessage, updateOrderData, createErrorResponse]);

  // ‚úÖ Gestion des choix avec protection
  const handleChoiceSelect = useCallback(async (choice: string) => {
    if (isProcessing) {
      console.log('‚è≥ Processing in progress, ignoring choice');
      return;
    }

    console.log('üîò Mobile choice selected:', choice);
    setIsProcessing(true);
    setShowTyping(true);
    
    try {
      await sendMessage(choice);
    } catch (error) {
      console.error('‚ùå Error sending choice:', error);
    } finally {
      setShowTyping(false);
      setIsProcessing(false);
    }
  }, [isProcessing, sendMessage]);

  // ‚úÖ Envoi de message depuis input
  const handleMessageSend = useCallback(async () => {
    if (!inputMessage.trim() || isProcessing) return;
    
    const message = inputMessage.trim();
    setInputMessage('');
    setIsProcessing(true);
    setShowTyping(true);
    
    try {
      await sendMessage(message);
    } catch (error) {
      console.error('‚ùå Error sending message:', error);
    } finally {
      setShowTyping(false);
      setIsProcessing(false);
    }
  }, [inputMessage, isProcessing, sendMessage]);

  const handleClosePaymentModal = useCallback(() => {
    setPaymentModal({ 
      isOpen: false, 
      iframeUrl: '', 
      provider: undefined 
    });
  }, [setPaymentModal]);

  // ‚úÖ RENDU CONDITIONNEL
  if (!initializationStarted) {
    return (
      <div className="fixed inset-0 bg-white z-50 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-[#FF7E93] mx-auto mb-4" />
          <p className="text-gray-600">Initialisation du chat...</p>
        </div>
      </div>
    );
  }

  return (
    <ConversationProvider 
      value={{
        productId: product.id,
        sessionId: sessionId,
        storeId,
        customerInfo: {
          firstName: orderData?.first_name || '',
          lastName: orderData?.last_name || '',
          city: orderData?.city || '',
          email: orderData?.email || ''
        }
      }}
    >
      <div className="fixed inset-0 bg-white z-50 flex flex-col touch-manipulation">
        {/* ‚úÖ HEADER STYLE ANCIEN - Plus √©pur√© */}
        <div className="sticky top-0 z-10 bg-white border-b shadow-sm">
          <div className="py-3 px-4 flex items-center gap-4">
            <button
              type="button"
              onClick={onBackClick}
              className="text-gray-600 p-2 hover:bg-gray-100 rounded-full transition-colors"
            >
              <ArrowLeft className="w-6 h-6" />
            </button>
            
            <div className="flex-shrink-0 w-8 h-8 rounded-lg overflow-hidden bg-gray-100">
              {product.images && product.images.length > 0 ? (
                <img
                  src={product.images[0]}
                  alt={product.name}
                  className="w-full h-full object-cover"
                />
              ) : (
                <div className="w-full h-full bg-gradient-to-br from-[#FF7E93] to-[#FF6B9D] flex items-center justify-center">
                  <span className="text-white text-xs font-bold">
                    {product.name.charAt(0)}
                  </span>
                </div>
              )}
            </div>
            
            <div className="flex-1">
              <h2 className="font-semibold text-[#132D5D] text-sm">Le Jeu {product.name}</h2>
              <div className="flex items-center gap-2">
                <div className="flex">
                  {[...Array(5)].map((_, i) => (
                    <Star
                      key={i}
                      className={`w-3 h-3 ${
                        i < rating
                          ? 'fill-[#FF7E93] text-[#FF7E93]'
                          : 'fill-gray-200 text-gray-200'
                      }`}
                    />
                  ))}
                </div>
                <span className="text-xs text-gray-600">
                  ({stats.reviewsCount} avis)
                </span>
              </div>
            </div>
          </div>

          {/* ‚úÖ CORRECTION MAJEURE : BARRE DE COMMANDE MOBILE - Maintenant fonctionnelle */}
          {cartInfo.hasItems && cartInfo.itemsCount > 0 && cartInfo.totalAmount > 0 && (
            <motion.div
              initial={{ opacity: 0, y: -20 }}
              animate={{ opacity: 1, y: 0 }}
              className="bg-gradient-to-r from-[#FF7E93]/10 to-[#FF6B9D]/10 border-t border-[#FF7E93]/20 px-4 py-3"
            >
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <div className="relative flex items-center justify-center w-6 h-6 bg-[#FF7E93] rounded-full">
                    <ShoppingBag className="w-3 h-3 text-white" />
                    {cartInfo.itemsCount > 0 && (
                      <div className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white text-xs rounded-full flex items-center justify-center font-bold">
                        {cartInfo.itemsCount}
                      </div>
                    )}
                  </div>
                  <div>
                    <p className="text-xs font-medium text-[#132D5D]">
                      Ma commande ({cartInfo.itemsCount} article{cartInfo.itemsCount > 1 ? 's' : ''})
                    </p>
                    <p className="text-xs text-gray-600 truncate max-w-[200px]">
                      {cartInfo.productName} x{cartInfo.itemsCount}
                    </p>
                  </div>
                </div>
                
                <div className="text-right">
                  <p className="text-sm font-bold text-[#FF7E93]">
                    {cartInfo.totalAmount.toLocaleString()} FCFA
                  </p>
                  <p className="text-xs text-gray-500">Total</p>
                </div>
              </div>
            </motion.div>
          )}
        </div>

        {/* ‚úÖ ZONE DES MESSAGES - Style ancien √©pur√© */}
        <div
          ref={chatRef}
          className="flex-1 overflow-y-auto bg-[#F0F2F5] p-4 space-y-4 overscroll-y-contain"
          style={{ WebkitOverflowScrolling: 'touch' }}
        >
          {messages && messages.length > 0 ? (
            <AnimatePresence mode="popLayout">
              {messages.map((message, index) => (
                <motion.div
                  key={`${message.type}-${index}-${message.timestamp}`}
                  initial={{ opacity: 0, y: 10 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0 }}
                  transition={{ duration: 0.2 }}
                >
                  <ChatMessage
                    message={message}
                    isTyping={false}
                    onChoiceSelect={handleChoiceSelect}
                  />

                  {message.metadata?.showQuantitySelector && !message.metadata?.quantityHandled && (
                    <div className="mt-4">
                      <QuantitySelector
                        quantity={1}
                        onQuantityChange={(qty: number) => {
                          if (message.metadata?.handleQuantityChange) {
                            message.metadata.handleQuantityChange(qty);
                          }
                        }}
                        onConfirm={async (qty: number) => {
                          if (message.metadata?.handleQuantitySubmit) {
                            await message.metadata.handleQuantitySubmit(qty);
                            if (message.metadata) {
                              message.metadata.quantityHandled = true;
                            }
                          }
                          handleChoiceSelect(qty.toString());
                        }}
                        maxQuantity={message.metadata?.maxQuantity || 10}
                      />
                    </div>
                  )}
                </motion.div>
              ))}

              {showTyping && (
                <motion.div
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  exit={{ opacity: 0 }}
                  key="typing-indicator"
                >
                  <TypingIndicator />
                </motion.div>
              )}
            </AnimatePresence>
          ) : (
            <div className="flex items-center justify-center h-full">
              <div className="text-center">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-[#FF7E93] mx-auto mb-2" />
                <p className="text-gray-500 text-sm">Chargement du chat...</p>
              </div>
            </div>
          )}
        </div>

        {/* ‚úÖ ZONE DE SAISIE AVEC VOCAL - Style ancien + vocal */}
        <div className="sticky bottom-0 left-0 right-0 bg-white border-t px-4 py-3">
          <VoiceEnabledInput
            value={inputMessage}
            onChange={setInputMessage}
            onSend={handleMessageSend}
            disabled={isProcessing}
            placeholder="Tapez votre message..."
          />
        </div>

        {/* ‚úÖ MODALS DE PAIEMENT CORRIG√âS */}
        <BictorysPaymentModal
          isOpen={paymentModal?.isOpen || false}
          onClose={handleClosePaymentModal}
          amount={orderData?.totalAmount || 0}
          currency="XOF"
          orderId={parseInt(orderData?.session_id || Date.now().toString())}
          customerInfo={{
            name: `${orderData?.first_name || ''} ${orderData?.last_name || ''}`.trim() || 'Client',
            phone: orderData?.phone || '',
            email: orderData?.email || '',
            city: orderData?.city || ''
          }}
        />

        {/* ‚úÖ CORRECTION MAJEURE: Modal Stripe corrig√© pour mobile */}
        <StripePaymentModal
          isOpen={stripeModalOpen}
          onClose={() => {
            setStripeModalOpen(false);
            setStripeModalData(null);
          }}
          amount={stripeModalData?.amount}
          orderId={stripeModalData?.orderId}
          currency="fcfa"
          onSuccess={(paymentIntentId) => {
            console.log('‚úÖ Mobile Stripe payment successful:', paymentIntentId);
            setStripeModalOpen(false);
            setStripeModalData(null);
            
            // ‚úÖ NOUVEAU: Envoyer message de confirmation SEULEMENT apr√®s succ√®s
            const confirmationMessage: ChatMessageType = {
              type: 'assistant',
              content: `üéâ **Paiement Stripe confirm√© !**

‚úÖ **Transaction r√©ussie :** ${paymentIntentId}
‚úÖ **Votre commande est maintenant confirm√©e**

**D√©tails de livraison :**
üìç ${orderData?.address || 'Adresse confirm√©e'}, ${orderData?.city || 'Ville confirm√©e'}
‚è∞ Livraison sous 24-48h ouvrables
üìû Nous vous tiendrons inform√©(e) via WhatsApp

üôè **Merci pour votre confiance en VIENS ON S'CONNA√éT !**`,
              choices: [
                '‚≠ê Parfait, merci !',
                'üõçÔ∏è Commander un autre jeu',
                'üì± T√©l√©charger l\'app mobile'
              ],
              assistant: { name: 'Rose', title: 'Assistante d\'achat' },
              metadata: {
                nextStep: 'express_completed' as ConversationStep,
                orderData: {
                  paymentMethod: 'card',
                  transactionId: paymentIntentId,
                  status: 'confirmed'
                },
                flags: { 
                  orderCompleted: true,
                  paymentConfirmed: true,
                  stripeVerified: true
                }
              },
              timestamp: new Date().toISOString()
            };
            
            addMessage(confirmationMessage);
          }}
          onError={(error) => {
            console.error('‚ùå Mobile Stripe payment error:', error);
            // ‚úÖ Le modal g√®re d√©j√† l'affichage de l'erreur
          }}
        />

        {/* Legacy Stripe modal pour compatibilit√© */}
        {payment?.status === 'processing' && payment?.clientSecret && (
          <StripePaymentModal
            isOpen={true}
            onClose={() => setStripeModalOpen(false)}
            clientSecret={payment.clientSecret}
          />
        )}
      </div>
    </ConversationProvider>
  );
};

export default MobileChatContainer;