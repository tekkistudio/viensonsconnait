// src/lib/services/AIChatIntegrationService.ts - VERSION COMPL√àTE

import { supabase } from '@/lib/supabase';
import { VoscAIAgent } from './VoscAIAgent';
import { ConversationalCartService } from './ConversationalCartService';
import type { 
  ChatMessage, 
  ConversationStep,
  CustomerData,
  ProductData,
  AIContext
} from '@/types/chat';

interface ChatSession {
  sessionId: string;
  productId?: string;
  customerId?: string;
  conversationHistory: ChatMessage[];
  currentStep: ConversationStep;
  metadata: Record<string, any>;
  createdAt: string;
  lastActivity: string;
}

export class AIChatIntegrationService {
  private static instance: AIChatIntegrationService;
  private voscAgent: VoscAIAgent;
  private cartService: ConversationalCartService;
  private activeSessions: Map<string, ChatSession> = new Map();

  private constructor() {
    this.voscAgent = VoscAIAgent.getInstance();
    this.cartService = ConversationalCartService.getInstance();
  }

  public static getInstance(): AIChatIntegrationService {
    if (!this.instance) {
      this.instance = new AIChatIntegrationService();
    }
    return this.instance;
  }

  /**
   * üöÄ M√âTHODE PRINCIPALE: Initialiser une nouvelle conversation
   */
  async initializeConversation(
    sessionId: string,
    productId?: string,
    initialContext?: Record<string, any>
  ): Promise<ChatMessage> {
    try {
      console.log('üé¨ Initialisation conversation IA:', { sessionId, productId });

      // Cr√©er ou r√©cup√©rer la session
      let session = await this.getOrCreateSession(sessionId, productId, initialContext);

      // Si c'est une nouvelle session, envoyer le message d'accueil
      if (session.conversationHistory.length === 0) {
        const welcomeMessage = await this.generateWelcomeMessage(session);
        
        // Ajouter le message √† l'historique
        session.conversationHistory.push(welcomeMessage);
        session.lastActivity = new Date().toISOString();
        
        // Sauvegarder la session
        await this.saveSession(session);
        
        return welcomeMessage;
      }

      // Retourner le dernier message de l'assistant
      const lastAssistantMessage = [...session.conversationHistory]
        .reverse()
        .find(msg => msg.type === 'assistant');

      return lastAssistantMessage || await this.generateWelcomeMessage(session);

    } catch (error) {
      console.error('‚ùå Erreur initialisation conversation:', error);
      return this.createErrorMessage(sessionId);
    }
  }

  /**
   * üí¨ M√âTHODE PRINCIPALE: Traiter un message utilisateur
   */
  async processUserMessage(
    sessionId: string,
    userMessage: string,
    productId?: string
  ): Promise<ChatMessage> {
    try {
      console.log('üí¨ Traitement message utilisateur:', { sessionId, userMessage, productId });

      // R√©cup√©rer la session
      const session = await this.getOrCreateSession(sessionId, productId);

      // Ajouter le message utilisateur √† l'historique
      const userChatMessage: ChatMessage = {
        type: 'user',
        content: userMessage,
        timestamp: new Date().toISOString()
      };
      
      session.conversationHistory.push(userChatMessage);

      // Pr√©parer le contexte pour l'Agent IA
      const aiContext: AIContext = {
        sessionId: session.sessionId,
        productId: session.productId,
        conversationHistory: session.conversationHistory,
        currentStep: session.currentStep,
        metadata: session.metadata,
        customerData: await this.extractCustomerData(session)
      };

      // Traiter avec l'Agent IA
      const aiResponse = await this.voscAgent.processUserMessage(userMessage, aiContext);

      // Ajouter la r√©ponse √† l'historique
      session.conversationHistory.push(aiResponse);
      
      // Mettre √† jour l'√©tape de conversation si sp√©cifi√©e
      if (aiResponse.metadata?.nextStep) {
        session.currentStep = aiResponse.metadata.nextStep;
      }

      // Traiter les actions sp√©ciales si pr√©sentes
      if (aiResponse.metadata?.actions) {
        await this.handleSpecialActions(aiResponse.metadata.actions, session, aiResponse);
      }

      // Mettre √† jour la session
      session.lastActivity = new Date().toISOString();
      await this.saveSession(session);

      return aiResponse;

    } catch (error) {
      console.error('‚ùå Erreur traitement message:', error);
      return this.createErrorMessage(sessionId);
    }
  }

  /**
   * üîÑ M√âTHODE: Traiter les choix par boutons
   */
  async processButtonChoice(
    sessionId: string,
    choice: string,
    productId?: string
  ): Promise<ChatMessage> {
    try {
      console.log('üîò Traitement choix bouton:', { sessionId, choice });

      // R√©cup√©rer la session
      const session = await this.getOrCreateSession(sessionId, productId);

      // Analyser le type de choix
      const choiceType = this.analyzeButtonChoice(choice);
      
      let responseMessage: string;
      let followUpMessage: ChatMessage;

      switch (choiceType.type) {
        case 'purchase_intent':
          responseMessage = `‚úÖ Parfait ! Vous avez choisi "${choice}"`;
          followUpMessage = await this.handlePurchaseFlow(session, choiceType.subType);
          break;

        case 'product_inquiry':
          responseMessage = `‚ùì Vous voulez en savoir plus : "${choice}"`;
          followUpMessage = await this.handleProductInquiry(session, choiceType.subType);
          break;

        case 'navigation':
          responseMessage = `üß≠ Navigation : "${choice}"`;
          followUpMessage = await this.handleNavigation(session, choiceType.subType);
          break;

        default:
          // Traiter comme un message normal
          return await this.processUserMessage(sessionId, choice, productId);
      }

      // Ajouter les messages √† l'historique
      const userChoice: ChatMessage = {
        type: 'user',
        content: responseMessage,
        timestamp: new Date().toISOString()
      };

      session.conversationHistory.push(userChoice, followUpMessage);
      session.lastActivity = new Date().toISOString();
      
      await this.saveSession(session);

      return followUpMessage;

    } catch (error) {
      console.error('‚ùå Erreur traitement choix:', error);
      return this.createErrorMessage(sessionId);
    }
  }

  /**
   * üì± M√âTHODE: G√©n√©rer message d'accueil personnalis√©
   */
  private async generateWelcomeMessage(session: ChatSession): Promise<ChatMessage> {
    try {
      // R√©cup√©rer les informations du produit si disponible
      let product: ProductData | null = null;
      
      if (session.productId) {
        const { data, error } = await supabase
          .from('products')
          .select('*')
          .eq('id', session.productId)
          .single();
        
        if (!error && data) {
          product = data;
        }
      }

      // R√©cup√©rer des statistiques pour la preuve sociale
      const { data: recentOrders } = await supabase
        .from('orders')
        .select('id')
        .eq('status', 'confirmed')
        .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString());

      const recentSalesCount = recentOrders?.length || 0;

      // Message d'accueil adapt√©
      let welcomeMessage = '';
      let choices: string[] = [];

      if (product) {
        // Accueil sp√©cifique au produit
        welcomeMessage = `üåü **Bonjour ! Je suis Rose, votre conseill√®re VIENS ON S'CONNA√éT.**

Je vois que **${product.name}** vous int√©resse ! 

${product.description || 'Ce jeu est parfait pour renforcer vos relations et cr√©er des moments magiques.'}

üí∞ **Prix:** ${product.price.toLocaleString()} FCFA`;

        if (recentSalesCount > 0) {
          welcomeMessage += `\n‚ú® **${recentSalesCount} personnes l'ont command√© cette semaine !**`;
        }

        welcomeMessage += `\n\nComment puis-je vous aider aujourd'hui ?`;

        choices = [
          '‚ö° Je veux l\'acheter maintenant',
          '‚ùì J\'ai des questions',
          'üéÆ Comment √ßa marche ?',
          '‚≠ê Avis clients'
        ];

        session.currentStep = 'product_engagement';

      } else {
        // Accueil g√©n√©ral de la marque
        welcomeMessage = `üåü **Bonjour ! Je suis Rose, votre conseill√®re VIENS ON S'CONNA√éT.**

Bienvenue dans l'univers des jeux de cartes relationnels qui transforment vos relations ! üéÆ‚ù§Ô∏è

üá∏üá≥ **Con√ßus au S√©n√©gal** pour les familles africaines
‚ú® **Plus de 1 000 familles satisfaites**
üöö **Livraison dans 12 pays africains**`;

        if (recentSalesCount > 0) {
          welcomeMessage += `\nüî• **${recentSalesCount} commandes cette semaine !**`;
        }

        welcomeMessage += `\n\nQue puis-je faire pour vous ?`;

        choices = [
          'üéÆ D√©couvrir vos jeux',
          'üõí Passer une commande',
          'üì± Votre application mobile',
          '‚ùì Poser une question'
        ];

        session.currentStep = 'initial_engagement';
      }

      return {
        type: 'assistant',
        content: welcomeMessage,
        choices,
        assistant: {
          name: 'Rose',
          title: 'Conseill√®re VIENS ON S\'CONNA√éT'
        },
        metadata: {
          nextStep: session.currentStep,
          sessionId: session.sessionId,
          productId: session.productId,
          welcomeMessage: true
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Erreur g√©n√©ration message d\'accueil:', error);
      return this.createErrorMessage(session.sessionId);
    }
  }

  /**
   * üõí M√âTHODE: G√©rer le flux d'achat
   */
  private async handlePurchaseFlow(
    session: ChatSession, 
    subType?: string
  ): Promise<ChatMessage> {
    try {
      const product = await this.getProductFromSession(session);
      
      if (!product) {
        return {
          type: 'assistant',
          content: `ü§ó **Je vais vous aider √† choisir le jeu parfait !**

Quel type de relations souhaitez-vous renforcer ?`,
          choices: [
            '‚ù§Ô∏è Couple',
            'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Famille',
            'üë´ Amis',
            'üíº Coll√®gues'
          ],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: { nextStep: 'product_selection' as ConversationStep },
          timestamp: new Date().toISOString()
        };
      }

      // Flux d'achat express ou guid√©
      if (subType === 'express') {
        return {
          type: 'assistant',
          content: `‚ö° **Commande Express - ${product.name}**

üí∞ **Prix:** ${product.price.toLocaleString()} FCFA
üöö **Livraison:** Rapide et s√©curis√©e

**√âtapes express (moins d'1 minute) :**
1Ô∏è‚É£ Quantit√© souhait√©e
2Ô∏è‚É£ Vos coordonn√©es
3Ô∏è‚É£ Adresse de livraison
4Ô∏è‚É£ Mode de paiement

Quelle quantit√© voulez-vous ?`,
          choices: ['1 jeu', '2 jeux', '3 jeux', 'Autre quantit√©'],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: { 
            nextStep: 'express_quantity' as ConversationStep,
            flow: 'express',
            productId: product.id
          },
          timestamp: new Date().toISOString()
        };
      }

      // Flux d'achat standard
      return {
        type: 'assistant',
        content: `üõí **Excellente d√©cision ! ${product.name}**

Laissez-moi vous accompagner pas √† pas pour finaliser votre commande.

Avant de commencer, avez-vous des questions sur :`,
        choices: [
          'üéÆ Comment jouer ?',
          'üöö La livraison',
          'üí≥ Le paiement',
          '‚ö° Non, commander directement'
        ],
        assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
        metadata: { 
          nextStep: 'pre_purchase_questions' as ConversationStep,
          productId: product.id
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Erreur flux d\'achat:', error);
      return this.createErrorMessage(session.sessionId);
    }
  }

  /**
   * ‚ùì M√âTHODE: G√©rer les questions sur le produit
   */
  private async handleProductInquiry(
    session: ChatSession, 
    subType?: string
  ): Promise<ChatMessage> {
    try {
      const product = await this.getProductFromSession(session);
      
      if (!product) {
        return {
          type: 'assistant',
          content: `‚ùì **Je suis l√† pour r√©pondre √† toutes vos questions !**

Sur quoi souhaitez-vous √™tre renseign√©(e) ?`,
          choices: [
            'üéÆ Nos jeux disponibles',
            'üöö Livraison et d√©lais',
            'üí≥ Modes de paiement',
            'üì± Application mobile'
          ],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: { nextStep: 'general_inquiry' as ConversationStep },
          timestamp: new Date().toISOString()
        };
      }

      switch (subType) {
        case 'rules':
          const rules = product.game_rules || 'Les r√®gles d√©taill√©es sont fournies avec le jeu.';
          return {
            type: 'assistant',
            content: `üéÆ **Comment jouer √† ${product.name} :**

${rules}

üïí **Dur√©e:** Adaptable (15 min √† 2h)
üë• **Joueurs:** Minimum 2 personnes
üéØ **But:** Cr√©er des conversations authentiques

Pr√™t(e) √† vivre cette exp√©rience ?`,
            choices: [
              '‚úÖ Oui, je veux l\'acheter !',
              'üíù Quels sont les b√©n√©fices ?',
              '‚≠ê Voir des t√©moignages'
            ],
            assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
            metadata: { nextStep: 'post_rules_engagement' as ConversationStep },
            timestamp: new Date().toISOString()
          };

        case 'benefits':
          return {
            type: 'assistant',
            content: `üíù **Les b√©n√©fices de ${product.name} :**

ü§ù **Relations renforc√©es** - Conversations profondes qui rapprochent
üí¨ **Communication am√©lior√©e** - Apprendre √† vraiment s'√©couter  
‚ù§Ô∏è **Moments privil√©gi√©s** - Temps de qualit√© sans distractions
üåü **Souvenirs durables** - Histoires √† partager en famille
‚ú® **Bien-√™tre** - R√©duction du stress, plus de complicit√©

Plus de 1 000 familles africaines t√©moignent de ces transformations !

Lequel de ces b√©n√©fices vous motive le plus ?`,
            choices: [
              'ü§ù Des relations plus fortes',
              'üí¨ Mieux communiquer',
              'üõí Je suis convaincu(e) !'
            ],
            assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
            metadata: { nextStep: 'benefits_engagement' as ConversationStep },
            timestamp: new Date().toISOString()
          };

        default:
          return {
            type: 'assistant',
            content: `üìã **√Ä propos de ${product.name} :**

${product.description || 'Un jeu con√ßu pour transformer vos relations.'}

**Ce qui le rend unique :**
‚ú® D√©velopp√© par des psychologues au S√©n√©gal
üá∏üá≥ Adapt√© √† la culture africaine
‚úÖ Test√© par 1 000+ familles
üéØ Questions pens√©es pour notre contexte

Que voulez-vous savoir de plus ?`,
            choices: [
              'üéÆ Comment y jouer ?',
              'üíù Quels b√©n√©fices ?',
              '‚≠ê T√©moignages clients',
              'üõí Je veux l\'acheter'
            ],
            assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
            metadata: { nextStep: 'product_details' as ConversationStep },
            timestamp: new Date().toISOString()
          };
      }

    } catch (error) {
      console.error('‚ùå Erreur inquiry produit:', error);
      return this.createErrorMessage(session.sessionId);
    }
  }

  /**
   * üß≠ M√âTHODE: G√©rer la navigation
   */
  private async handleNavigation(
    session: ChatSession, 
    subType?: string
  ): Promise<ChatMessage> {
    try {
      switch (subType) {
        case 'all_products':
          const { data: products } = await supabase
            .from('products')
            .select('*')
            .eq('status', 'active')
            .order('created_at', { ascending: false });

          if (!products || products.length === 0) {
            return {
              type: 'assistant',
              content: `üòî **Aucun produit disponible pour le moment.**

Nous travaillons sur de nouveaux jeux passionnants ! 

üìû **Contactez-nous pour √™tre inform√©(e) :**
WhatsApp : +221 78 136 27 28`,
              choices: ['üìû Contacter sur WhatsApp', 'üè† Retour accueil'],
              assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
              metadata: { nextStep: 'no_products' as ConversationStep },
              timestamp: new Date().toISOString()
            };
          }

          const productList = products.map(p => 
            `üéÆ **${p.name}**\nüí∞ ${p.price.toLocaleString()} FCFA\nüìù ${(p.description || '').substring(0, 80)}...`
          ).join('\n\n');

          return {
            type: 'assistant',
            content: `üéÆ **Nos jeux disponibles :**

${productList}

Lequel vous int√©resse le plus ?`,
            choices: [
              ...products.slice(0, 3).map(p => p.name),
              'üìû Conseil personnalis√©'
            ],
            assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
            metadata: { 
              nextStep: 'product_selection' as ConversationStep,
              availableProducts: products
            },
            timestamp: new Date().toISOString()
          };

        case 'mobile_app':
          return {
            type: 'assistant',
            content: `üì± **Application VIENS ON S'CONNA√éT**

üéÆ **Tous vos jeux dans votre poche !**

‚ú® **Fonctionnalit√©s :**
‚Ä¢ üÉè Acc√®s √† vos jeux achet√©s
‚Ä¢ üé≤ Mode hors ligne
‚Ä¢ üë• Partage avec la famille
‚Ä¢ üìä Suivi de vos parties
‚Ä¢ üÜï Nouveaux contenus

üì≤ **T√©l√©chargement gratuit :**
‚Ä¢ App Store (iOS)
‚Ä¢ Google Play Store (Android)

üéÅ **Bonus :** 50 questions offertes !

Souhaitez-vous t√©l√©charger l'app ?`,
            choices: [
              'üì≤ T√©l√©charger maintenant',
              'üéÆ D\'abord un jeu physique',
              '‚ùì Comment √ßa fonctionne ?'
            ],
            assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
            metadata: { 
              nextStep: 'mobile_app_interest' as ConversationStep,
              externalLinks: {
                appStore: 'https://apps.apple.com/viensonseconnait',
                playStore: 'https://play.google.com/store/apps/viensonseconnait'
              }
            },
            timestamp: new Date().toISOString()
          };

        case 'whatsapp':
          return {
            type: 'assistant',
            content: `üìû **Contact WhatsApp**

Je vais vous rediriger vers notre √©quipe WhatsApp pour un accompagnement personnalis√©.

**Notre √©quipe est disponible :**
üïê Lundi - Vendredi : 8h - 18h
üïê Samedi : 9h - 15h
üì± +221 78 136 27 28

Voulez-vous √™tre redirig√©(e) maintenant ?`,
            choices: [
              'üì± Oui, rediriger vers WhatsApp',
              'üí¨ Continuer ici',
              'üìß Pr√©f√©rer l\'email'
            ],
            assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
            metadata: { 
              nextStep: 'whatsapp_redirect' as ConversationStep,
              whatsappUrl: 'https://wa.me/221781362728'
            },
            timestamp: new Date().toISOString()
          };

        default:
          return {
            type: 'assistant',
            content: `üß≠ **Menu principal**

Comment puis-je vous aider ?`,
            choices: [
              'üéÆ Voir tous les jeux',
              'üõí Passer une commande',
              'üì± Application mobile',
              'üìû Nous contacter'
            ],
            assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
            metadata: { nextStep: 'main_menu' as ConversationStep },
            timestamp: new Date().toISOString()
          };
      }

    } catch (error) {
      console.error('‚ùå Erreur navigation:', error);
      return this.createErrorMessage(session.sessionId);
    }
  }

  /**
   * ‚öôÔ∏è M√âTHODE: Traiter les actions sp√©ciales
   */
  private async handleSpecialActions(
    actions: string[], 
    session: ChatSession, 
    message: ChatMessage
  ): Promise<void> {
    try {
      for (const action of actions) {
        switch (action) {
          case 'start_express_order':
            // Initialiser le panier conversationnel
            await this.cartService.getOrCreateCart(session.sessionId, session.productId);
            break;

          case 'show_products':
            // Marquer l'int√©r√™t pour les produits
            session.metadata.showedProducts = true;
            break;

          case 'track_app_interest':
            // Tracker l'int√©r√™t pour l'application
            session.metadata.appInterest = true;
            break;

          case 'prepare_support_transfer':
            // Pr√©parer le transfert vers le support
            session.metadata.supportTransfer = {
              timestamp: new Date().toISOString(),
              reason: 'user_request'
            };
            break;

          case 'prepare_order_options':
            // Pr√©parer les options de commande
            session.metadata.orderPreparation = true;
            break;

          default:
            console.log('‚ö†Ô∏è Action non reconnue:', action);
        }
      }

    } catch (error) {
      console.error('‚ùå Erreur actions sp√©ciales:', error);
    }
  }

  /**
   * üîç M√âTHODES UTILITAIRES
   */

  private async getOrCreateSession(
    sessionId: string, 
    productId?: string, 
    initialContext?: Record<string, any>
  ): Promise<ChatSession> {
    
    // V√©rifier le cache en m√©moire
    let session: ChatSession | undefined = this.activeSessions.get(sessionId);
    
    if (!session) {
      // Essayer de charger depuis la base de donn√©es
      const loadedSession = await this.loadSessionFromDatabase(sessionId);
        if (loadedSession) {
        session = loadedSession;
        }
      
      if (!session) {
        // Cr√©er une nouvelle session
        session = {
          sessionId,
          productId,
          conversationHistory: [],
          currentStep: 'initial_engagement',
          metadata: {
            createdAt: new Date().toISOString(),
            ...initialContext
          },
          createdAt: new Date().toISOString(),
          lastActivity: new Date().toISOString()
        };
      }
      
      this.activeSessions.set(sessionId, session);
    }

    // Mettre √† jour le productId si fourni et diff√©rent
    if (productId && session.productId !== productId) {
      session.productId = productId;
      session.metadata.productChanged = true;
    }

    return session;
  }

  private async loadSessionFromDatabase(sessionId: string): Promise<ChatSession | null> {
    try {
      const { data: conversation, error } = await supabase
        .from('conversations')
        .select('*')
        .eq('session_id', sessionId)
        .single();

      if (error || !conversation) {
        return null;
      }

      // Charger les messages de la conversation
      const { data: messages, error: messagesError } = await supabase
        .from('chat_messages')
        .select('*')
        .eq('conversation_id', conversation.id)
        .order('created_at', { ascending: true });

      if (messagesError) {
        console.error('‚ùå Erreur chargement messages:', messagesError);
        return null;
      }

      // Reconstituer la session
      const session: ChatSession = {
        sessionId: conversation.session_id,
        productId: conversation.product_id,
        customerId: conversation.customer_id,
        conversationHistory: messages?.map(msg => ({
          type: msg.type as 'user' | 'assistant',
          content: msg.content,
          choices: msg.choices,
          assistant: msg.assistant_info,
          metadata: msg.metadata,
          timestamp: msg.created_at
        })) || [],
        currentStep: conversation.current_step as ConversationStep,
        metadata: conversation.metadata || {},
        createdAt: conversation.created_at,
        lastActivity: conversation.last_activity
      };

      return session;

    } catch (error) {
      console.error('‚ùå Erreur chargement session:', error);
      return null;
    }
  }

  private async saveSession(session: ChatSession): Promise<void> {
    try {
      // Sauvegarder la conversation
      const { data: conversation, error: conversationError } = await supabase
        .from('conversations')
        .upsert({
          session_id: session.sessionId,
          product_id: session.productId,
          customer_id: session.customerId,
          current_step: session.currentStep,
          metadata: session.metadata,
          last_activity: session.lastActivity,
          created_at: session.createdAt
        }, {
          onConflict: 'session_id'
        })
        .select()
        .single();

      if (conversationError) {
        console.error('‚ùå Erreur sauvegarde conversation:', conversationError);
        return;
      }

      // Sauvegarder les nouveaux messages
      const existingMessageCount = await this.getExistingMessageCount(conversation.id);
      const newMessages = session.conversationHistory.slice(existingMessageCount);

      if (newMessages.length > 0) {
        const messagesToInsert = newMessages.map(msg => ({
          conversation_id: conversation.id,
          type: msg.type,
          content: msg.content,
          choices: msg.choices,
          assistant_info: msg.assistant,
          metadata: msg.metadata,
          created_at: msg.timestamp
        }));

        const { error: messagesError } = await supabase
          .from('chat_messages')
          .insert(messagesToInsert);

        if (messagesError) {
          console.error('‚ùå Erreur sauvegarde messages:', messagesError);
        }
      }

      // Mettre √† jour le cache
      this.activeSessions.set(session.sessionId, session);

    } catch (error) {
      console.error('‚ùå Erreur sauvegarde session:', error);
    }
  }

  private async getExistingMessageCount(conversationId: string): Promise<number> {
    const { count, error } = await supabase
      .from('chat_messages')
      .select('*', { count: 'exact', head: true })
      .eq('conversation_id', conversationId);

    if (error) {
      console.error('‚ùå Erreur comptage messages:', error);
      return 0;
    }

    return count || 0;
  }

  private async getProductFromSession(session: ChatSession): Promise<ProductData | null> {
    if (!session.productId) return null;

    try {
      const { data: product, error } = await supabase
        .from('products')
        .select('*')
        .eq('id', session.productId)
        .single();

      return error ? null : product;
    } catch (error) {
      return null;
    }
  }

  private async extractCustomerData(session: ChatSession): Promise<Partial<CustomerData> | undefined> {
    // Extraire les donn√©es client des m√©tadonn√©es ou de l'historique
    const customerData: Partial<CustomerData> = {};

    // Rechercher dans les m√©tadonn√©es
    if (session.metadata.customerPhone) {
      customerData.phone = session.metadata.customerPhone;
    }
    
    if (session.metadata.customerName) {
      customerData.first_name = session.metadata.customerName;
    }

    // Rechercher un client existant si on a le t√©l√©phone
    if (customerData.phone) {
      try {
        const { data: existingCustomer } = await supabase
          .from('customers')
          .select('*')
          .eq('phone', customerData.phone)
          .single();

        if (existingCustomer) {
          return existingCustomer;
        }
      } catch (error) {
        // Client non trouv√©, continuer avec les donn√©es partielles
      }
    }

    return Object.keys(customerData).length > 0 ? customerData : undefined;
  }

  private analyzeButtonChoice(choice: string): { type: string; subType?: string } {
    const lowerChoice = choice.toLowerCase();

    // Intentions d'achat
    if (lowerChoice.includes('acheter') || lowerChoice.includes('commander') || 
        lowerChoice.includes('maintenant') || lowerChoice.includes('express')) {
      const subType = lowerChoice.includes('express') ? 'express' : 'standard';
      return { type: 'purchase_intent', subType };
    }

    // Questions sur le produit
    if (lowerChoice.includes('comment') || lowerChoice.includes('r√®gle') || 
        lowerChoice.includes('jouer') || lowerChoice.includes('fonctionne')) {
      return { type: 'product_inquiry', subType: 'rules' };
    }

    if (lowerChoice.includes('b√©n√©fice') || lowerChoice.includes('avantage')) {
      return { type: 'product_inquiry', subType: 'benefits' };
    }

    // Navigation
    if (lowerChoice.includes('jeux') || lowerChoice.includes('produit')) {
      return { type: 'navigation', subType: 'all_products' };
    }

    if (lowerChoice.includes('app') || lowerChoice.includes('mobile')) {
      return { type: 'navigation', subType: 'mobile_app' };
    }

    if (lowerChoice.includes('whatsapp') || lowerChoice.includes('contact')) {
      return { type: 'navigation', subType: 'whatsapp' };
    }

    return { type: 'general' };
  }

  private createErrorMessage(sessionId: string): ChatMessage {
    return {
      type: 'assistant',
      content: `üòî **D√©sol√©e, une erreur technique est survenue.**

Voici vos options :

üìû **Contact imm√©diat :**
WhatsApp : +221 78 136 27 28

üîÑ **R√©essayer :**
Reformulez votre demande

Que pr√©f√©rez-vous ?`,
      choices: [
        'üîÑ R√©essayer',
        'üìû WhatsApp',
        'üè† Retour accueil'
      ],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'error_recovery' as ConversationStep,
        sessionId,
        error: 'true'
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üßπ M√âTHODE: Nettoyer les sessions inactives
   */
  async cleanupInactiveSessions(): Promise<void> {
    const now = new Date();
    const inactivityThreshold = 24 * 60 * 60 * 1000; // 24 heures

    for (const [sessionId, session] of this.activeSessions.entries()) {
      const lastActivity = new Date(session.lastActivity);
      const timeSinceLastActivity = now.getTime() - lastActivity.getTime();

      if (timeSinceLastActivity > inactivityThreshold) {
        this.activeSessions.delete(sessionId);
        console.log(`üßπ Session nettoy√©e: ${sessionId}`);
      }
    }
  }

  /**
   * üìä M√âTHODE: Obtenir les statistiques des conversations
   */
  async getConversationStats(): Promise<{
    activeSessions: number;
    totalConversations: number;
    averageMessagesPerConversation: number;
    conversionRate: number;
  }> {
    try {
      const activeSessions = this.activeSessions.size;

      const { data: conversations, error } = await supabase
        .from('conversations')
        .select('id')
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());

      const totalConversations = conversations?.length || 0;

      const { data: messages } = await supabase
        .from('chat_messages')
        .select('conversation_id')
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());

      const averageMessagesPerConversation = totalConversations > 0 ? 
        (messages?.length || 0) / totalConversations : 0;

      const { data: orders } = await supabase
        .from('orders')
        .select('id, metadata')
        .eq('status', 'confirmed')
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());

      const chatOrders = orders?.filter(order => 
        order.metadata?.source === 'chat' || order.metadata?.source === 'chatbot'
      ).length || 0;

      const conversionRate = totalConversations > 0 ? 
        (chatOrders / totalConversations) * 100 : 0;

      return {
        activeSessions,
        totalConversations,
        averageMessagesPerConversation: Math.round(averageMessagesPerConversation * 10) / 10,
        conversionRate: Math.round(conversionRate * 10) / 10
      };

    } catch (error) {
      console.error('‚ùå Erreur statistiques conversations:', error);
      return {
        activeSessions: 0,
        totalConversations: 0,
        averageMessagesPerConversation: 0,
        conversionRate: 0
      };
    }
  }
}