// src/lib/services/ConversationalCartService.ts - VERSION CORRIG√âE
import { supabase } from '@/lib/supabase';
import type { ChatMessage, ChatOrderData, ConversationStep } from '@/types/chat';

interface CartItem {
  productId: string;
  name: string;
  quantity: number;
  price: number;
  totalPrice: number;
  addedAt: string;
}

interface ConversationalCart {
  sessionId: string;
  items: CartItem[];
  currentProductId?: string; // Produit actuellement consult√©
  totalAmount: number;
  deliveryCost: number;
  lastUpdated: string;
}

export class ConversationalCartService {
  private static instance: ConversationalCartService;
  private carts: Map<string, ConversationalCart> = new Map();

  private constructor() {}

  public static getInstance(): ConversationalCartService {
    if (!this.instance) {
      this.instance = new ConversationalCartService();
    }
    return this.instance;
  }

  // ‚úÖ CORRECTION: INITIALISER OU R√âCUP√âRER UN PANIER
  async getOrCreateCart(sessionId: string, currentProductId?: string): Promise<ConversationalCart> {
    let cart: ConversationalCart | undefined = this.carts.get(sessionId);
    
    if (!cart) {
      // ‚úÖ CORRECTION: Essayer de r√©cup√©rer depuis la base de donn√©es
      const loadedCart = await this.loadCartFromDatabase(sessionId);
      
      if (loadedCart) {
        cart = loadedCart;
      } else {
        // Cr√©er un nouveau panier
        cart = {
          sessionId,
          items: [],
          currentProductId,
          totalAmount: 0,
          deliveryCost: 0,
          lastUpdated: new Date().toISOString()
        };
      }
      
      this.carts.set(sessionId, cart);
    }

    // Mettre √† jour le produit actuellement consult√©
    if (currentProductId && cart.currentProductId !== currentProductId) {
      cart.currentProductId = currentProductId;
      cart.lastUpdated = new Date().toISOString();
      await this.saveCartToDatabase(cart);
    }

    return cart;
  }

  // ‚úÖ AJOUTER UN PRODUIT AU PANIER CONVERSATIONNEL
  async addProductToCart(
    sessionId: string, 
    productId: string, 
    quantity: number = 1
  ): Promise<ChatMessage> {
    console.log('üõí Adding product to conversational cart:', { sessionId, productId, quantity });

    try {
      // R√©cup√©rer le panier
      const cart = await this.getOrCreateCart(sessionId, productId);
      
      // R√©cup√©rer les infos du produit
      const { data: product, error } = await supabase
        .from('products')
        .select('id, name, price, status')
        .eq('id', productId)
        .eq('status', 'active')
        .single();

      if (error || !product) {
        return this.createErrorMessage('Produit non trouv√© ou indisponible');
      }

      // V√©rifier si le produit existe d√©j√† dans le panier
      const existingItemIndex = cart.items.findIndex(item => item.productId === productId);
      
      if (existingItemIndex !== -1) {
        // Mettre √† jour la quantit√©
        cart.items[existingItemIndex].quantity += quantity;
        cart.items[existingItemIndex].totalPrice = cart.items[existingItemIndex].quantity * product.price;
      } else {
        // Ajouter un nouveau produit
        const newItem: CartItem = {
          productId: product.id,
          name: product.name,
          quantity,
          price: product.price,
          totalPrice: product.price * quantity,
          addedAt: new Date().toISOString()
        };
        cart.items.push(newItem);
      }

      // Recalculer le total
      cart.totalAmount = cart.items.reduce((sum, item) => sum + item.totalPrice, 0) + cart.deliveryCost;
      cart.lastUpdated = new Date().toISOString();

      // Sauvegarder
      await this.saveCartToDatabase(cart);
      this.carts.set(sessionId, cart);

      return {
        type: 'assistant',
        content: `‚úÖ **${product.name} ajout√© √† la commande !**

üõí **Votre commande (${cart.items.length} article${cart.items.length > 1 ? 's' : ''}) :**
${cart.items.map(item => `‚Ä¢ ${item.name} x${item.quantity} = ${item.totalPrice.toLocaleString()} FCFA`).join('\n')}

üí∞ **Total actuel :** ${cart.totalAmount.toLocaleString()} FCFA

Que souhaitez-vous faire maintenant ?`,
        choices: [
          'üõçÔ∏è Continuer mes achats',
          'üì¶ Finaliser ma commande',
          'üóëÔ∏è Modifier la commande',
          'üëÄ Voir d\'autres jeux'
        ],
        assistant: {
          name: 'Rose',
          title: 'Assistante d\'achat'
        },
        metadata: {
          nextStep: 'cart_management' as ConversationStep,
          orderData: this.convertCartToOrderData(cart),
          flags: {
            productAdded: true,
            hasMultipleProducts: cart.items.length > 1
          }
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Error adding product to cart:', error);
      return this.createErrorMessage('Erreur lors de l\'ajout √† la commande');
    }
  }

  // ‚úÖ G√âRER LA NAVIGATION ENTRE PRODUITS
  async handleProductNavigation(
    sessionId: string,
    newProductId: string,
    fromProductId?: string
  ): Promise<ChatMessage> {
    console.log('üîÑ Handling product navigation:', { sessionId, newProductId, fromProductId });

    try {
      const cart = await this.getOrCreateCart(sessionId, newProductId);
      
      // R√©cup√©rer les infos du nouveau produit
      const { data: product, error } = await supabase
        .from('products')
        .select('id, name, price, description')
        .eq('id', newProductId)
        .single();

      if (error || !product) {
        return this.createErrorMessage('Produit non trouv√©');
      }

      // V√©rifier s'il y a d√©j√† des articles dans le panier
      if (cart.items.length > 0) {
        const cartSummary = cart.items.map(item => `‚Ä¢ ${item.name} x${item.quantity}`).join('\n');
        
        return {
          type: 'assistant',
          content: `üëã **Heureuse de vous revoir sur la page du jeu ${product.name} !**

üõí **Votre commande actuel :**
${cartSummary}

üí∞ **Total : ${cart.totalAmount.toLocaleString()} FCFA**

Souhaitez-vous ajouter ce jeu √† votre commande existante ou commencer une nouvelle commande ?`,
          choices: [
            `‚ûï Ajouter le jeu ${product.name} √† la commande`,
            'üì¶ Finaliser ma commande actuelle',
            'üóëÔ∏è Vider la commande et recommencer',
            'üí¨ En savoir plus sur ce jeu'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: 'product_navigation_choice' as ConversationStep,
            productId: newProductId,
            orderData: this.convertCartToOrderData(cart),
            flags: {
              hasExistingCart: true,
              productNavigation: true
            }
          },
          timestamp: new Date().toISOString()
        };
      } else {
        // Panier vide, message de bienvenue standard
        return {
          type: 'assistant',
          content: `üëã **Bonjour ! Je suis Rose.**

Je vais vous aider avec le jeu **${product.name}** !

Comment puis-je vous aider aujourd'hui ?`,
          choices: [
            '‚ö° Commander rapidement',
            '‚ùì Poser une question',
            'üì¶ Infos livraison',
            'üí¨ En savoir plus'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: 'initial_engagement' as ConversationStep,
            productId: newProductId,
            flags: {
              isWelcome: true,
              emptyCart: true
            }
          },
          timestamp: new Date().toISOString()
        };
      }

    } catch (error) {
      console.error('‚ùå Error handling product navigation:', error);
      return this.createErrorMessage('Erreur lors de la navigation');
    }
  }

  // ‚úÖ MODIFIER LA QUANTIT√â D'UN PRODUIT
  async updateProductQuantity(
    sessionId: string,
    productId: string,
    newQuantity: number
  ): Promise<ChatMessage> {
    console.log('üî¢ Updating product quantity:', { sessionId, productId, newQuantity });

    try {
      const cart = await this.getOrCreateCart(sessionId);
      const itemIndex = cart.items.findIndex(item => item.productId === productId);

      if (itemIndex === -1) {
        return this.createErrorMessage('Produit non trouv√© dans la commande');
      }

      if (newQuantity <= 0) {
        // Retirer le produit du panier
        const removedItem = cart.items.splice(itemIndex, 1)[0];
        cart.totalAmount = cart.items.reduce((sum, item) => sum + item.totalPrice, 0) + cart.deliveryCost;
        
        await this.saveCartToDatabase(cart);
        
        return {
          type: 'assistant',
          content: `üóëÔ∏è **${removedItem.name} retir√© de la commande**

${cart.items.length > 0 ? 
  `üõí **Commande restante :**\n${cart.items.map(item => `‚Ä¢ ${item.name} x${item.quantity}`).join('\n')}\n\nüí∞ **Nouveau total :** ${cart.totalAmount.toLocaleString()} FCFA` 
  : 'üõí **Votre commande est maintenant vide**'
}

Que souhaitez-vous faire ?`,
          choices: cart.items.length > 0 ? [
            'üì¶ Finaliser ma commande',
            'üõçÔ∏è Continuer mes achats',
            'üóëÔ∏è Modifier la commande'
          ] : [
            'üõçÔ∏è Reprendre mes achats',
            'üëÄ Voir nos jeux populaires',
            'üìû Contacter le support'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: cart.items.length > 0 ? 'cart_management' : 'empty_cart' as ConversationStep,
            orderData: this.convertCartToOrderData(cart)
          },
          timestamp: new Date().toISOString()
        };
      } else {
        // Mettre √† jour la quantit√©
        cart.items[itemIndex].quantity = newQuantity;
        cart.items[itemIndex].totalPrice = cart.items[itemIndex].price * newQuantity;
        cart.totalAmount = cart.items.reduce((sum, item) => sum + item.totalPrice, 0) + cart.deliveryCost;
        
        await this.saveCartToDatabase(cart);
        
        return {
          type: 'assistant',
          content: `‚úÖ **Quantit√© mise √† jour !**

üõí **Votre commande :**
${cart.items.map(item => `‚Ä¢ ${item.name} x${item.quantity} = ${item.totalPrice.toLocaleString()} FCFA`).join('\n')}

üí∞ **Total : ${cart.totalAmount.toLocaleString()} FCFA**

Que souhaitez-vous faire maintenant ?`,
          choices: [
            'üì¶ Finaliser ma commande',
            'üõçÔ∏è Continuer mes achats',
            'üóëÔ∏è Modifier la commande',
            'üí¨ Ajouter une note'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: 'cart_management' as ConversationStep,
            orderData: this.convertCartToOrderData(cart),
            flags: {
              quantityUpdated: true
            }
          },
          timestamp: new Date().toISOString()
        };
      }

    } catch (error) {
      console.error('‚ùå Error updating product quantity:', error);
      return this.createErrorMessage('Erreur lors de la mise √† jour');
    }
  }

  // ‚úÖ AFFICHER LE R√âSUM√â DU PANIER
  async getCartSummary(sessionId: string): Promise<ChatMessage> {
    console.log('üìã Getting cart summary:', sessionId);

    try {
      const cart = await this.getOrCreateCart(sessionId);

      if (cart.items.length === 0) {
        return {
          type: 'assistant',
          content: `üõí **Votre commande est vide**

D√©couvrez nos jeux de cartes pour transformer vos relations !

Que souhaitez-vous faire ?`,
          choices: [
            'üéØ Voir nos jeux populaires',
            'üíï Jeux pour couples',
            'üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Jeux pour familles',
            'üìû Contacter le support'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: 'empty_cart_options' as ConversationStep
          },
          timestamp: new Date().toISOString()
        };
      }

      const subtotal = cart.items.reduce((sum, item) => sum + item.totalPrice, 0);

      return {
        type: 'assistant',
        content: `üõí **R√©sum√© de votre commande**

üì¶ **Articles (${cart.items.length}) :**
${cart.items.map(item => `‚Ä¢ ${item.name} x${item.quantity} = ${item.totalPrice.toLocaleString()} FCFA`).join('\n')}

üí∞ **D√©tail :**
‚Ä¢ Sous-total : ${subtotal.toLocaleString()} FCFA
‚Ä¢ Livraison : ${cart.deliveryCost.toLocaleString()} FCFA
‚Ä¢ **Total : ${cart.totalAmount.toLocaleString()} FCFA**

Que souhaitez-vous faire ?`,
        choices: [
          'üì¶ Finaliser ma commande',
          'üõçÔ∏è Continuer mes achats',
          '‚úèÔ∏è Modifier les quantit√©s',
          'üóëÔ∏è Vider la commande'
        ],
        assistant: {
          name: 'Rose',
          title: 'Assistante d\'achat'
        },
        metadata: {
          nextStep: 'cart_summary_actions' as ConversationStep,
          orderData: this.convertCartToOrderData(cart),
          flags: {
            cartSummaryShown: true
          }
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Error getting cart summary:', error);
      return this.createErrorMessage('Erreur lors de l\'affichage de la commande');
    }
  }

  // ‚úÖ VIDER LE PANIER
  async clearCart(sessionId: string): Promise<ChatMessage> {
    console.log('üóëÔ∏è Clearing cart:', sessionId);

    try {
      const cart: ConversationalCart = {
        sessionId,
        items: [],
        totalAmount: 0,
        deliveryCost: 0,
        lastUpdated: new Date().toISOString()
      };

      await this.saveCartToDatabase(cart);
      this.carts.set(sessionId, cart);

      return {
        type: 'assistant',
        content: `üóëÔ∏è **Commande vid√©e avec succ√®s**

Vous pouvez recommencer vos achats quand vous le souhaitez !

Que souhaitez-vous faire maintenant ?`,
        choices: [
          'üõçÔ∏è Reprendre mes achats',
          'üéØ Voir les jeux populaires',
          'üí¨ Poser une question',
          'üìû Contacter le support'
        ],
        assistant: {
          name: 'Rose',
          title: 'Assistante d\'achat'
        },
        metadata: {
          nextStep: 'fresh_start' as ConversationStep,
          flags: {
            cartCleared: true
          }
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Error clearing cart:', error);
      return this.createErrorMessage('Erreur lors de la suppression');
    }
  }

  // ‚úÖ CONVERTIR LE PANIER EN DONN√âES DE COMMANDE
  private convertCartToOrderData(cart: ConversationalCart): Partial<ChatOrderData> {
    return {
      session_id: cart.sessionId,
      items: cart.items.map(item => ({
        productId: item.productId,
        name: item.name,
        quantity: item.quantity,
        price: item.price,
        totalPrice: item.totalPrice
      })),
      subtotal: cart.items.reduce((sum, item) => sum + item.totalPrice, 0),
      delivery_cost: cart.deliveryCost,
      total_amount: cart.totalAmount
    };
  }

  // ‚úÖ SAUVEGARDER LE PANIER EN BASE
  private async saveCartToDatabase(cart: ConversationalCart): Promise<void> {
    try {
      const { error } = await supabase
        .from('conversations')
        .upsert({
          id: cart.sessionId,
          session_data: {
            cart: cart,
            updatedAt: new Date().toISOString()
          },
          updated_at: new Date().toISOString()
        }, { onConflict: 'id' });

      if (error) {
        console.error('‚ùå Error saving cart:', error);
      }
    } catch (error) {
      console.error('‚ùå Error in saveCartToDatabase:', error);
    }
  }

  // ‚úÖ CORRECTION: CHARGER LE PANIER DEPUIS LA BASE - Type corrig√©
  private async loadCartFromDatabase(sessionId: string): Promise<ConversationalCart | undefined> {
    try {
      const { data, error } = await supabase
        .from('conversations')
        .select('session_data')
        .eq('id', sessionId)
        .single();

      if (error || !data?.session_data?.cart) {
        return undefined; // ‚úÖ CORRECTION: Retourner undefined au lieu de null
      }

      return data.session_data.cart as ConversationalCart;
    } catch (error) {
      console.error('‚ùå Error loading cart from database:', error);
      return undefined; // ‚úÖ CORRECTION: Retourner undefined au lieu de null
    }
  }

  // ‚úÖ MESSAGE D'ERREUR STANDARDIS√â
  private createErrorMessage(errorText: string): ChatMessage {
    return {
      type: 'assistant',
      content: `üòî **${errorText}**

Voulez-vous r√©essayer ?`,
      choices: [
        'üîÑ R√©essayer',
        'üìû Contacter le support',
        'üîô Retour au menu'
      ],
      assistant: {
        name: 'Rose',
        title: 'Assistante d\'achat'
      },
      metadata: {
        nextStep: 'error_recovery' as ConversationStep,
        flags: {
          hasError: true
        }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ M√âTHODES UTILITAIRES
  async getCartItemsCount(sessionId: string): Promise<number> {
    const cart = await this.getOrCreateCart(sessionId);
    return cart.items.reduce((sum, item) => sum + item.quantity, 0);
  }

  async getCartTotal(sessionId: string): Promise<number> {
    const cart = await this.getOrCreateCart(sessionId);
    return cart.totalAmount;
  }

  async hasProductInCart(sessionId: string, productId: string): Promise<boolean> {
    const cart = await this.getOrCreateCart(sessionId);
    return cart.items.some(item => item.productId === productId);
  }

  async getProductQuantityInCart(sessionId: string, productId: string): Promise<number> {
    const cart = await this.getOrCreateCart(sessionId);
    const item = cart.items.find(item => item.productId === productId);
    return item ? item.quantity : 0;
  }
}