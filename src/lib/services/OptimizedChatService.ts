// src/lib/services/OptimizedChatService.ts 

import { supabase } from '@/lib/supabase';
import type { 
  ChatMessage, 
  ConversationStep, 
  ChatOrderData,
  PaymentProvider,
  ProductData
} from '@/types/chat';
import { WelcomeMessageService } from './WelcomeMessageService';
import { OrderService } from './OrderService';
import { PhoneService } from './PhoneService';

// Types pour le flow express
interface ExpressOrderState {
  step: 'quantity' | 'phone' | 'name' | 'address' | 'payment' | 'confirmation';
  data: {
    productId: string;
    productName: string;
    unitPrice: number;
    quantity: number;
    phone?: string;
    firstName?: string;
    lastName?: string;
    city?: string;
    address?: string;
    paymentMethod?: PaymentProvider;
  };
  flags: {
    isExistingCustomer: boolean;
    needsNameCollection: boolean;
    needsAddressCollection: boolean;
  };
}

export class OptimizedChatService {
  private static instance: OptimizedChatService;
  private orderStates = new Map<string, ExpressOrderState>();
  private welcomeService = WelcomeMessageService.getInstance();
  private orderService = OrderService.getInstance();
  private phoneService = PhoneService.getInstance();

  private constructor() {
    console.log('üîß OptimizedChatService v2.0 initialized');
  }

  public static getInstance(): OptimizedChatService {
    if (!this.instance) {
      this.instance = new OptimizedChatService();
    }
    return this.instance;
  }

  // ‚úÖ M√âTHODE PRINCIPALE : Traiter les messages
  public async processMessage(
    sessionId: string,
    message: string,
    currentStep: ConversationStep,
    productId: string,
    productName: string
  ): Promise<ChatMessage> {
    try {
      console.log('üìù Processing message:', { sessionId, message, currentStep, productId });

      // 1. G√©rer les boutons du message d'accueil
      if (this.isWelcomeButtonChoice(message)) {
        return this.welcomeService.handleWelcomeButtonResponse(message, productId, productName);
      }

      // 2. G√©rer le flow express (√©tapes sc√©naris√©es)
      if (currentStep.startsWith('express_') || this.orderStates.has(sessionId)) {
        return await this.handleExpressFlowInternal(sessionId, message, currentStep, productId, productName);
      }

      // 3. G√©rer les questions pr√©d√©finies
      if (this.isPredefinedQuestion(message)) {
        return await this.handlePredefinedQuestion(message, productId, productName);
      }

      // 4. Questions libres ‚Üí Router vers l'API IA
      return await this.handleFreeTextQuestion(message, productId, productName, sessionId);

    } catch (error) {
      console.error('‚ùå Error processing message:', error);
      return this.createErrorMessage('Une erreur est survenue. Voulez-vous r√©essayer ?');
    }
  }

  // ‚úÖ GESTION DU FLOW EXPRESS INTERNE (nom chang√© pour √©viter le doublon)
  private async handleExpressFlowInternal(
    sessionId: string,
    message: string,
    currentStep: ConversationStep,
    productId: string,
    productName: string
  ): Promise<ChatMessage> {
    
    let orderState = this.orderStates.get(sessionId);
    
    // Initialiser l'√©tat si premi√®re fois
    if (!orderState && currentStep === 'express_quantity') {
      const product = await this.getProductData(productId);
      orderState = {
        step: 'quantity',
        data: {
          productId,
          productName,
          unitPrice: product.price,
          quantity: 1
        },
        flags: {
          isExistingCustomer: false,
          needsNameCollection: true,
          needsAddressCollection: true
        }
      };
      this.orderStates.set(sessionId, orderState);
    }

    if (!orderState) {
      return this.createErrorMessage('Session expir√©e. Veuillez recommencer votre commande.');
    }

    // Router selon l'√©tape
    switch (orderState.step) {
      case 'quantity':
        return await this.handleQuantityStep(sessionId, message, orderState);
      case 'phone':
        return await this.handlePhoneStep(sessionId, message, orderState);
      case 'name':
        return await this.handleNameStep(sessionId, message, orderState);
      case 'address':
        return await this.handleAddressStep(sessionId, message, orderState);
      case 'payment':
        return await this.handlePaymentStep(sessionId, message, orderState);
      case 'confirmation':
        return await this.handleConfirmationStep(sessionId, message, orderState);
      default:
        return this.createErrorMessage('√âtape inconnue dans la commande express.');
    }
  }

  // ‚úÖ √âTAPE 1 : Quantit√©
  private async handleQuantityStep(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    let quantity = 1;

    // Parser la quantit√©
    if (message.includes('1 exemplaire')) quantity = 1;
    else if (message.includes('2 exemplaires')) quantity = 2;
    else if (message.includes('3 exemplaires')) quantity = 3;
    else if (message.includes('Autre quantit√©')) {
      return {
        type: 'assistant',
        content: `üî¢ **Quantit√© personnalis√©e**

Combien d'exemplaires de **${orderState.data.productName}** souhaitez-vous ?

*Saisissez un nombre entre 1 et 10*`,
        choices: [],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_custom_quantity' as ConversationStep,
          flags: { awaitingNumericInput: true }
        },
        timestamp: new Date().toISOString()
      };
    } else {
      // Essayer de parser un nombre
      const numMatch = message.match(/(\d+)/);
      if (numMatch) {
        quantity = parseInt(numMatch[1]);
        if (quantity < 1 || quantity > 10) {
          return this.createErrorMessage('Veuillez choisir une quantit√© entre 1 et 10.');
        }
      } else {
        return this.createErrorMessage('Veuillez s√©lectionner une quantit√© valide.');
      }
    }

    // Mettre √† jour l'√©tat
    orderState.data.quantity = quantity;
    orderState.step = 'phone';
    this.orderStates.set(sessionId, orderState);

    const totalAmount = orderState.data.unitPrice * quantity;

    return {
      type: 'assistant',
      content: `‚úÖ **${quantity} exemplaire${quantity > 1 ? 's' : ''} de ${orderState.data.productName}**

**Montant total :** ${totalAmount.toLocaleString()} FCFA

Pour finaliser votre commande, j'ai besoin de votre num√©ro de t√©l√©phone :

*Exemple : +221 77 123 45 67*`,
      choices: [],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'express_phone' as ConversationStep,
        orderData: {
          productId: orderState.data.productId,
          productName: orderState.data.productName,
          quantity: quantity,
          unitPrice: orderState.data.unitPrice,
          totalAmount: totalAmount,
          session_id: sessionId
        },
        flags: { awaitingPhoneInput: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ √âTAPE 2 : T√©l√©phone
  private async handlePhoneStep(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    // Valider le t√©l√©phone
    const phoneValidation = this.phoneService.validatePhoneNumber(message, 'SN');
    
    if (!phoneValidation.isValid) {
      return {
        type: 'assistant',
        content: `‚ùå **Num√©ro invalide**

${phoneValidation.error}

Veuillez saisir un num√©ro valide :

*Exemple : +221 77 123 45 67*`,
        choices: [],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_phone' as ConversationStep,
          flags: { phoneError: true }
        },
        timestamp: new Date().toISOString()
      };
    }

    // Formater le t√©l√©phone
    const { international } = this.phoneService.formatPhoneWithCountry(message, 'SN');
    orderState.data.phone = international;

    // V√©rifier si client existant
    const { data: existingCustomer } = await supabase
      .from('customers')
      .select('first_name, last_name, city, address')
      .eq('phone', international)
      .maybeSingle();

    if (existingCustomer) {
      // Client existant
      orderState.data.firstName = existingCustomer.first_name;
      orderState.data.lastName = existingCustomer.last_name;
      orderState.data.city = existingCustomer.city;
      orderState.data.address = existingCustomer.address;
      orderState.flags.isExistingCustomer = true;
      orderState.flags.needsNameCollection = false;
      orderState.flags.needsAddressCollection = false;
      orderState.step = 'payment';
      this.orderStates.set(sessionId, orderState);

      return {
        type: 'assistant',
        content: `üëã **Ravi de vous revoir ${existingCustomer.first_name} !**

J'ai retrouv√© vos informations :
üìç **Adresse :** ${existingCustomer.address}, ${existingCustomer.city}

Souhaitez-vous utiliser la m√™me adresse pour cette livraison ?`,
        choices: [
          'Oui, m√™me adresse',
          'Changer d\'adresse'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_address_confirmation' as ConversationStep,
          flags: { existingCustomer: true }
        },
        timestamp: new Date().toISOString()
      };
    } else {
      // Nouveau client
      orderState.step = 'name';
      this.orderStates.set(sessionId, orderState);

      return {
        type: 'assistant',
        content: `üì± **Parfait ! Num√©ro enregistr√© : ${international}**

Maintenant, quel est votre nom complet ?

*Exemple : Amadou Diallo*`,
        choices: [],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_name' as ConversationStep,
          flags: { awaitingNameInput: true }
        },
        timestamp: new Date().toISOString()
      };
    }
  }

  // ‚úÖ √âTAPE 3 : Nom (nouveaux clients uniquement)
  private async handleNameStep(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    const name = message.trim();
    
    if (name.length < 2) {
      return this.createErrorMessage('Le nom doit contenir au moins 2 caract√®res.');
    }

    const parts = name.split(/\s+/);
    if (parts.length < 2) {
      return this.createErrorMessage('Veuillez saisir votre pr√©nom et nom.');
    }

    orderState.data.firstName = parts[0];
    orderState.data.lastName = parts.slice(1).join(' ');
    orderState.step = 'address';
    this.orderStates.set(sessionId, orderState);

    return {
      type: 'assistant',
      content: `üë§ **Merci ${orderState.data.firstName} !**

Maintenant, quelle est votre adresse de livraison ?

*Exemple : Cit√© Keur Gorgui, Villa 123, Dakar*`,
      choices: [],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'express_address' as ConversationStep,
        flags: { awaitingAddressInput: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ √âTAPE 4 : Adresse
  private async handleAddressStep(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    // ‚úÖ CORRECTION 1: Reconna√Ætre toutes les variantes de "Oui, m√™me adresse"
    const confirmationMessages = [
      'oui, m√™me adresse',
      'oui m√™me adresse', 
      'm√™me adresse',
      'oui',
      'confirmer',
      'garder la m√™me',
      'conserver l\'adresse'
    ];
    
    const isAddressConfirmation = confirmationMessages.some(phrase => 
      message.toLowerCase().includes(phrase.toLowerCase())
    );

    if (isAddressConfirmation) {
      // ‚úÖ L'utilisateur confirme l'adresse existante
      console.log('‚úÖ User confirmed existing address');
      
      // Passer √† l'√©tape paiement
      orderState.step = 'payment';
      this.orderStates.set(sessionId, orderState);

      const totalAmount = orderState.data.unitPrice * orderState.data.quantity;

      return {
        type: 'assistant',
        content: `‚úÖ **Parfait ! Adresse confirm√©e**

üìç **Livraison √† :** ${orderState.data.address}, ${orderState.data.city}

üí∞ **R√©capitulatif :**
‚Ä¢ ${orderState.data.quantity}x ${orderState.data.productName}
‚Ä¢ **Total : ${totalAmount.toLocaleString()} FCFA**

üéØ **Derni√®re √©tape : Choisissez votre mode de paiement**`,
        choices: [
          'üì± Wave (recommand√©)',
          'üí≥ Carte bancaire', 
          'üíµ Paiement √† la livraison'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_payment' as ConversationStep,
          orderData: orderState.data,
          flags: { addressConfirmed: true }
        },
        timestamp: new Date().toISOString()
      };
    }

    // ‚úÖ CORRECTION 2: Reconna√Ætre "Changer d'adresse"
    const changeAddressMessages = [
      'changer d\'adresse',
      'changer adresse',
      'nouvelle adresse',
      'autre adresse',
      'modifier',
      'diff√©rente'
    ];
    
    const isAddressChange = changeAddressMessages.some(phrase => 
      message.toLowerCase().includes(phrase.toLowerCase())
    );

    if (isAddressChange) {
      return {
        type: 'assistant',
        content: `üìç **Nouvelle adresse de livraison**

Veuillez indiquer votre nouvelle adresse compl√®te :

**Format :** Quartier/Rue, Ville
**Exemple :** Mermoz, Dakar`,
        choices: [],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_address' as ConversationStep,
          flags: { 
            collectingNewAddress: true,
            addressChangeRequested: true 
          }
        },
        timestamp: new Date().toISOString()
      };
    }

    // ‚úÖ CORRECTION 3: Traiter une nouvelle adresse saisie
    if (message.trim().length > 5) {
      const addressParts = message.split(',').map(part => part.trim());
      
      if (addressParts.length >= 2) {
        // Format: "Rue/Quartier, Ville"
        orderState.data.address = addressParts[0];
        orderState.data.city = addressParts[1];
      } else {
        // Une seule partie - consid√©rer comme adresse, garder la ville existante
        orderState.data.address = message.trim();
        if (!orderState.data.city) {
          orderState.data.city = 'Dakar'; // Valeur par d√©faut
        }
      }

      // Passer √† l'√©tape paiement
      orderState.step = 'payment';
      this.orderStates.set(sessionId, orderState);

      const totalAmount = orderState.data.unitPrice * orderState.data.quantity;

      return {
        type: 'assistant',
        content: `‚úÖ **Nouvelle adresse enregistr√©e !**

üìç **Livraison √† :** ${orderState.data.address}, ${orderState.data.city}

üí∞ **R√©capitulatif :**
‚Ä¢ ${orderState.data.quantity}x ${orderState.data.productName}
‚Ä¢ **Total : ${totalAmount.toLocaleString()} FCFA**

üéØ **Choisissez votre mode de paiement**`,
        choices: [
          'üì± Wave (recommand√©)',
          'üí≥ Carte bancaire', 
          'üíµ Paiement √† la livraison'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_payment' as ConversationStep,
          orderData: orderState.data,
          flags: { 
            addressUpdated: true,
            newAddressSet: true 
          }
        },
        timestamp: new Date().toISOString()
      };
    }

    // ‚úÖ Message d'erreur si le format n'est pas reconnu
    return {
      type: 'assistant',
      content: `üòÖ **Je n'ai pas bien compris votre choix**

Voulez-vous :
‚Ä¢ **Garder l'adresse actuelle** : ${orderState.data.address || 'Non d√©finie'}, ${orderState.data.city || 'Non d√©finie'}
‚Ä¢ **Ou saisir une nouvelle adresse** ?

Vous pouvez aussi taper directement votre nouvelle adresse (format: Quartier, Ville)`,
      choices: [
        'Oui, m√™me adresse',
        'Changer d\'adresse'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'express_address' as ConversationStep,
        flags: { 
          addressConfirmationPending: true,
          retryAddressStep: true 
        }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ M√âTHODE AUXILIAIRE: D√©tecter si l'utilisateur confirme l'adresse
  private detectAddressConfirmation(message: string): boolean {
    const confirmations = [
      'oui',
      'oui, m√™me adresse',
      'm√™me adresse',
      'garder',
      'conserver',
      'confirmer',
      'ok',
      'd\'accord',
      'parfait'
    ];
    
    const lowerMessage = message.toLowerCase().trim();
    return confirmations.some(conf => lowerMessage.includes(conf));
  }

  // ‚úÖ M√âTHODE AUXILIAIRE: D√©tecter si l'utilisateur veut changer l'adresse
  private detectAddressChange(message: string): boolean {
    const changes = [
      'changer',
      'modifier',
      'nouvelle',
      'autre',
      'diff√©rente',
      'non'
    ];
    
    const lowerMessage = message.toLowerCase().trim();
    return changes.some(change => lowerMessage.includes(change));
  }

  // ‚úÖ CR√âER MESSAGE DE PAIEMENT avec int√©gration Wave/Stripe
  private async createPaymentMessage(orderState: ExpressOrderState): Promise<ChatMessage> {
    const totalAmount = orderState.data.unitPrice * orderState.data.quantity;
    const isDakar = orderState.data.city?.toLowerCase().includes('dakar');

    // D√©terminer les options de paiement selon la zone
    const paymentChoices = isDakar 
      ? [
          `üåä Payer ${totalAmount.toLocaleString()} FCFA avec Wave`,
          `üí≥ Payer ${totalAmount.toLocaleString()} FCFA par Carte`,
          `üõµ Payer ${totalAmount.toLocaleString()} FCFA √† la livraison`
        ]
      : [
          `üåä Payer ${totalAmount.toLocaleString()} FCFA avec Wave`,
          `üí≥ Payer ${totalAmount.toLocaleString()} FCFA par Carte`
        ];

    return {
      type: 'assistant',
      content: `üí≥ **Choisissez votre mode de paiement**

**R√©capitulatif :**
üéÆ ${orderState.data.productName} x${orderState.data.quantity}
üìç ${orderState.data.city}
üí∞ **Total : ${totalAmount.toLocaleString()} FCFA**

Comment souhaitez-vous payer ?`,
      choices: paymentChoices,
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'express_payment' as ConversationStep,
        paymentAmount: totalAmount, // ‚úÖ NOUVEAU: Montant pour paiement direct
        orderData: {
          totalAmount: totalAmount,
          city: orderState.data.city,
          productId: orderState.data.productId,
          productName: orderState.data.productName,
          quantity: orderState.data.quantity,
          first_name: orderState.data.firstName,
          last_name: orderState.data.lastName,
          phone: orderState.data.phone,
          address: orderState.data.address
        },
        flags: { paymentSelection: true, enableDirectPayment: true } // ‚úÖ Flag pour paiement direct
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ √âTAPE 5 : Paiement (Trait√© maintenant par ChatMessage directement)
  private async handlePaymentStep(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    // ‚úÖ Si le paiement a √©t√© trait√© directement dans ChatMessage, on confirme
    if (message.includes('Paiement') && message.includes('confirm√©')) {
      return await this.handlePaymentConfirmation(sessionId, orderState, message);
    }

    // ‚úÖ Fallback pour paiements non directs  
    let paymentMethod: PaymentProvider;

    if (message.toLowerCase().includes('wave')) {
      paymentMethod = 'wave';
    } else if (message.toLowerCase().includes('carte')) {
      paymentMethod = 'card';
    } else if (message.toLowerCase().includes('livraison')) {
      paymentMethod = 'CASH'; // ‚úÖ Maintenant compatible avec le type
    } else {
      return this.createErrorMessage('Veuillez choisir un mode de paiement valide.');
    }


    orderState.data.paymentMethod = paymentMethod;
    orderState.step = 'confirmation';
    this.orderStates.set(sessionId, orderState);

    // Cr√©er la commande
    const orderResult = await this.createOrder(sessionId, orderState);
    
    if (!orderResult.success) {
      return this.createErrorMessage(orderResult.error || 'Erreur lors de la cr√©ation de la commande');
    }

    return {
      type: 'assistant',
      content: `‚úÖ **Commande confirm√©e !**

**Num√©ro de commande :** #${orderResult.orderId}

${this.getPaymentInstructions(paymentMethod)}

**Livraison :** 24-48h ouvrables √† ${orderState.data.city}

Voulez-vous recevoir la confirmation par SMS ?`,
      choices: [
        'üì± Recevoir SMS',
        '‚úÖ C\'est parfait',
        'üõçÔ∏è Ajouter un autre jeu'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'express_completed' as ConversationStep,
        orderData: {
          orderId: orderResult.orderId,
          paymentMethod: paymentMethod,
          status: 'confirmed'
        },
        flags: { orderCompleted: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ NOUVEAU: G√©rer la confirmation de paiement apr√®s traitement direct
  private async handlePaymentConfirmation(
    sessionId: string,
    orderState: ExpressOrderState,
    message: string
  ): Promise<ChatMessage> {
    
    // Extraire le type de paiement du message
    let paymentMethod: PaymentProvider = 'wave';
    if (message.includes('Carte')) paymentMethod = 'card';
    if (message.includes('livraison')) paymentMethod = 'CASH';

    orderState.data.paymentMethod = paymentMethod;
    orderState.step = 'confirmation';
    this.orderStates.set(sessionId, orderState);

    // Cr√©er la commande
    const orderResult = await this.createOrder(sessionId, orderState);
    
    if (!orderResult.success) {
      return this.createErrorMessage(orderResult.error || 'Erreur lors de la cr√©ation de la commande');
    }

    return {
      type: 'assistant',
      content: `üéâ **Paiement confirm√© !**

**Num√©ro de commande :** #${orderResult.orderId}
**Statut :** Commande valid√©e ‚úÖ

Votre commande sera trait√©e dans les plus brefs d√©lais.

Que souhaitez-vous faire maintenant ?`,
      choices: [
        'üì¶ Suivre ma commande',
        'üõçÔ∏è Commander un autre jeu',
        'üì± T√©l√©charger l\'app mobile',
        '‚úÖ Parfait, merci !'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'post_purchase' as ConversationStep,
        orderData: {
          orderId: orderResult.orderId,
          paymentMethod: paymentMethod,
          status: 'confirmed'
        },
        flags: { orderCompleted: true, paymentConfirmed: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ √âTAPE 6 : Confirmation finale
  private async handleConfirmationStep(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    // Nettoyer l'√©tat de commande
    this.orderStates.delete(sessionId);

    if (message.includes('Recevoir SMS')) {
      return {
        type: 'assistant',
        content: `üì± **SMS envoy√© !**

Vous recevrez toutes les informations sur votre commande par SMS.

Merci pour votre confiance ! üôè`,
        choices: [
          'üõçÔ∏è Voir d\'autres jeux',
          'üì± T√©l√©charger l\'app mobile',
          '‚úÖ Parfait, merci !'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'post_purchase' as ConversationStep,
          flags: { orderCompleted: true, smsRequested: true }
        },
        timestamp: new Date().toISOString()
      };
    }

    if (message.includes('Ajouter un autre jeu')) {
      return await this.createUpsellMessage(orderState.data.productId);
    }

    return {
      type: 'assistant',
      content: `‚úÖ **Merci pour votre commande !**

Votre jeu **${orderState.data.productName}** sera livr√© dans les plus brefs d√©lais.

üéÆ **Profitez bien de votre exp√©rience VIENS ON S'CONNA√éT !**`,
      choices: [
        'üõçÔ∏è Commander un autre jeu',
        'üì± T√©l√©charger l\'app mobile',
        '‚≠ê Laisser un avis'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'post_purchase' as ConversationStep,
        flags: { orderCompleted: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ GESTION DES QUESTIONS PR√âD√âFINIES
  private async handlePredefinedQuestion(
    message: string,
    productId: string,
    productName: string
  ): Promise<ChatMessage> {
    
    if (message.includes('comment y jouer') || message.includes('Comment y jouer')) {
      return {
        type: 'assistant',
        content: `üéÆ **Comment jouer √† ${productName} :**

**C'est tr√®s simple :**
1Ô∏è‚É£ **M√©langez** les 150 cartes
2Ô∏è‚É£ **Chacun votre tour**, tirez une carte
3Ô∏è‚É£ **Lisez la question** √† voix haute
4Ô∏è‚É£ **R√©pondez sinc√®rement** et √©coutez la r√©ponse de l'autre
5Ô∏è‚É£ **√âchangez** sur vos r√©ponses respectives

üéØ **L'objectif :** Cr√©er des conversations profondes et authentiques pour mieux vous comprendre !

üí° **Astuce :** Prenez votre temps, il n'y a pas de bonnes ou mauvaises r√©ponses.`,
        choices: [
          'Je veux l\'acheter maintenant',
          'C\'est pour qui ?',
          'Quels sont les b√©n√©fices ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'game_rules_shown' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };
    }

    if (message.includes('c\'est pour qui') || message.includes('C\'est pour qui')) {
      return {
        type: 'assistant',
        content: `üë• **${productName} est parfait pour :**

‚ù§Ô∏è **Les couples** qui veulent renforcer leur complicit√©
üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **Les familles** qui souhaitent cr√©er des liens plus forts  
üë´ **Les amis** qui veulent approfondir leur amiti√©
üíº **Les coll√®gues** pour am√©liorer la coh√©sion d'√©quipe
üîÑ **Toute relation** qui m√©rite d'√™tre enrichie

‚ú® **Peu importe votre √¢ge ou votre situation**, nos jeux s'adaptent √† tous !

üéØ **L'important :** Avoir envie de cr√©er des moments authentiques ensemble.`,
        choices: [
          'Je veux l\'acheter maintenant',
          'Comment y jouer ?',
          'Quels sont les b√©n√©fices ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'target_audience_shown' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };
    }

    if (message.includes('b√©n√©fices') || message.includes('Quels sont les b√©n√©fices')) {
      return {
        type: 'assistant',
        content: `‚ú® **Les b√©n√©fices de ${productName} :**

üéØ **Communication am√©lior√©e**
‚Ä¢ Conversations plus profondes et authentiques
‚Ä¢ Meilleure √©coute mutuelle

‚ù§Ô∏è **Relation renforc√©e**  
‚Ä¢ Complicit√© accrue
‚Ä¢ Confiance mutuelle d√©velopp√©e

üîç **D√©couverte mutuelle**
‚Ä¢ Apprendre des choses nouvelles sur l'autre
‚Ä¢ Comprendre ses valeurs et ses r√™ves

üòå **Bien-√™tre relationnel**
‚Ä¢ Moins de malentendus
‚Ä¢ Plus de moments complices

üéÅ **Bonus :** Des souvenirs inoubliables √† chaque partie !`,
        choices: [
          'Je veux l\'acheter maintenant',
          'Comment y jouer ?',
          'C\'est pour qui ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'benefits_shown' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };
    }

    // Question g√©n√©rale par d√©faut
    return {
      type: 'assistant',
      content: `ü§î **Bonne question !** 

Je suis l√† pour vous aider avec toutes vos interrogations sur **${productName}**.

Que souhaitez-vous savoir exactement ?`,
      choices: [
        'Comment y jouer ?',
        'C\'est pour qui ?',
        'Quels sont les b√©n√©fices ?'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'question_mode' as ConversationStep,
        productId: productId
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ GESTION DES QUESTIONS LIBRES avec IA
  private async handleFreeTextQuestion(
    message: string,
    productId: string,
    productName: string,
    sessionId: string
  ): Promise<ChatMessage> {
    try {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: message,
          productId: productId,
          currentStep: 'question_mode',
          orderData: {},
          sessionId: sessionId,
          storeId: 'a9563f88-217c-4998-b080-ed39f637ea31'
        }),
      });

      if (!response.ok) {
        throw new Error(`API error: ${response.status}`);
      }

      const aiResponse = await response.json();

      return {
        type: 'assistant',
        content: aiResponse.message || "Je suis l√† pour vous aider !",
        choices: aiResponse.choices || [
          'Je veux l\'acheter maintenant',
          'Autre question',
          'Parler √† un conseiller'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'ai_response' as ConversationStep,
          productId: productId,
          flags: { aiGenerated: true }
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Error calling AI API:', error);
      
      return {
        type: 'assistant',
        content: `Je comprends votre question sur **${productName}**.

Malheureusement, je rencontre un probl√®me technique pour vous r√©pondre en d√©tail.

üìû **Contactez-nous directement :**
WhatsApp : +221 78 136 27 28

Ou choisissez une option ci-dessous :`,
        choices: [
          'Je veux l\'acheter maintenant',
          'Comment y jouer ?',
          'C\'est pour qui ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'fallback_response' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };
    }
  }

  // ‚úÖ M√âTHODES DE R√âCUP√âRATION DE DONN√âES PRODUIT
  private async getGameRules(productId: string, productName: string): Promise<ChatMessage> {
    try {
      const { data: product } = await supabase
        .from('products')
        .select('game_rules')
        .eq('id', productId)
        .single();

      const gameRules = product?.game_rules || 
        `üéÆ **Comment jouer au jeu ${productName} :**

üìã **R√®gles simples :**
‚Ä¢ M√©langez les cartes
‚Ä¢ Chaque joueur tire une carte √† tour de r√¥le
‚Ä¢ Lisez la question/d√©fi √† voix haute
‚Ä¢ R√©pondez de mani√®re authentique
‚Ä¢ √âcoutez et √©changez avec bienveillance

‚è∞ **Dur√©e :** 30-60 minutes
üë• **Participants :** 2 personnes minimum
‚ú® **Objectif :** Cr√©er des conversations m√©morables`;

      return {
        type: 'assistant',
        content: gameRules,
        choices: [
          'Je veux l\'acheter maintenant',
          'C\'est pour qui ?',
          'Quels sont les b√©n√©fices ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'post_rules_engagement' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Error fetching game rules:', error);
      return this.createErrorMessage('Impossible de r√©cup√©rer les r√®gles du jeu.');
    }
  }

  private async getTargetAudience(productId: string, productName: string): Promise<ChatMessage> {
    try {
      const { data: product } = await supabase
        .from('products')
        .select('target_audience')
        .eq('id', productId)
        .single();

      const targetAudience = product?.target_audience || 
        `üë• **Le jeu ${productName} est parfait pour :**

üíë **Les couples** qui veulent renforcer leur complicit√©
üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **Les familles** qui cherchent √† mieux se conna√Ætre
üë´ **Les amis** qui veulent approfondir leur amiti√©
üëî **Les coll√®gues** pour am√©liorer la coh√©sion d'√©quipe

‚ú® **√Çge recommand√© :** √Ä partir de 16 ans
üéØ **Id√©al pour :** Tous ceux qui veulent des relations plus authentiques`;

      return {
        type: 'assistant',
        content: targetAudience,
        choices: [
          'Je veux l\'acheter maintenant',
          'Comment y jouer ?',
          'Quels sont les b√©n√©fices ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'target_audience_shown' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Error fetching target audience:', error);
      return this.createErrorMessage('Impossible de r√©cup√©rer les informations sur le public cible.');
    }
  }

  private async getBenefits(productId: string, productName: string): Promise<ChatMessage> {
    try {
      const { data: product } = await supabase
        .from('products')
        .select('benefits')
        .eq('id', productId)
        .single();

      const benefits = product?.benefits || 
        `üíù **Les b√©n√©fices du jeu ${productName} :**

üî• **Renforce la complicit√©** entre vous et vos proches
üí¨ **Facilite la communication** sur des sujets importants
‚ú® **Cr√©e des souvenirs m√©morables** et des moments d'intimit√©
üåü **D√©veloppe l'empathie** et la compr√©hension mutuelle
‚ù§Ô∏è **Approfondit les relations** de mani√®re naturelle et amusante

üéØ **R√©sultat :** Des liens plus forts et une meilleure connaissance de l'autre`;

      return {
        type: 'assistant',
        content: benefits,
        choices: [
          'Je veux l\'acheter maintenant',
          'Comment y jouer ?',
          'C\'est pour qui ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'benefits_shown' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Error fetching benefits:', error);
      return this.createErrorMessage('Impossible de r√©cup√©rer les b√©n√©fices du jeu.');
    }
  }

  private async getTestimonials(productId: string, productName: string): Promise<ChatMessage> {
    try {
      const { data: testimonials } = await supabase
        .from('testimonials')
        .select('*')
        .eq('product_id', productId)
        .eq('is_approved', true)
        .order('created_at', { ascending: false })
        .limit(3);

      let content = '';

      if (!testimonials || testimonials.length === 0) {
        content = `‚≠ê **Ce que disent nos clients sur ${productName} :**

Nous collectons actuellement les premiers t√©moignages de nos clients.

üîÑ **En attendant, d√©couvrez pourquoi nos jeux fonctionnent :**
‚Ä¢ M√©thode test√©e et approuv√©e
‚Ä¢ Conception bas√©e sur la psychologie des relations
‚Ä¢ D√©j√† des centaines de couples/familles transform√©s

üí¨ **Pr√™t(e) √† vivre cette exp√©rience ?**`;
      } else {
        const testimonialTexts = testimonials.map(t => {
          const stars = '‚≠ê'.repeat(t.rating);
          return `${stars} **${t.author_name || 'Client'}** ${t.author_location ? `(${t.author_location})` : ''}\n"${t.content}"`;
        }).join('\n\n');
        
        content = `‚≠ê **Ce que disent nos clients sur ${productName} :**

${testimonialTexts}

üí¨ **Et vous, pr√™t(e) √† vivre cette exp√©rience ?**`;
      }

      return {
        type: 'assistant',
        content: content,
        choices: [
          'Je veux l\'acheter maintenant',
          'Comment y jouer ?',
          'C\'est pour qui ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'testimonials_shown' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Error fetching testimonials:', error);
      return this.createErrorMessage('Impossible de r√©cup√©rer les t√©moignages.');
    }
  }

  // ‚úÖ CR√âER UNE COMMANDE - CORRIG√â AVEC BONS TYPES
  private async createOrder(
  sessionId: string,
  orderState: ExpressOrderState
): Promise<{ success: boolean; orderId?: string; error?: string }> {
  try {
    // ‚úÖ CORRECTION: Pr√©parer les donn√©es selon le format attendu par OrderService
    const orderData = {
      session_id: sessionId,
      product_id: orderState.data.productId,
      store_id: 'a9563f88-217c-4998-b080-ed39f637ea31',
      quantity: orderState.data.quantity,
      phone: orderState.data.phone!,
      first_name: orderState.data.firstName!,
      last_name: orderState.data.lastName!,
      city: orderState.data.city!,
      address: orderState.data.address!,
      payment_method: orderState.data.paymentMethod!,
      total_amount: orderState.data.unitPrice * orderState.data.quantity,
      status: 'pending' as const
    };

    console.log('üì¶ Creating order with data:', orderData);

    // ‚úÖ OPTION A: Si OrderService.createOrder attend un string (JSON)
    let result;
    try {
      result = await this.orderService.createOrder(JSON.stringify(orderData));
    } catch (jsonError) {
      // ‚úÖ OPTION B: Si OrderService.createOrder attend l'objet directement
      console.log('üì¶ Trying with object format...');
      result = await this.orderService.createOrder(orderData as any);
    }
    
    console.log('üì¶ Order service result:', result);

    // ‚úÖ CORRECTION: Gestion flexible du r√©sultat
    if (result && typeof result === 'object') {
      // Si le r√©sultat a une propri√©t√© success
      if ('success' in result) {
        const orderResult = result as { success: boolean; order?: { id: string }; error?: string };
        
        if (orderResult.success && orderResult.order) {
          return {
            success: true,
            orderId: orderResult.order.id
          };
        } else {
          return {
            success: false,
            error: orderResult.error || 'Erreur lors de la cr√©ation de la commande'
          };
        }
      }
      // Si le r√©sultat est directement l'ordre cr√©√©
      else if ('id' in result) {
        return {
          success: true,
          orderId: (result as any).id
        };
      }
    }
    
    // Si result est une string (message d'erreur)
    if (typeof result === 'string') {
      return {
        success: false,
        error: result
      };
    }

    // Fallback
    return {
      success: false,
      error: 'Format de r√©ponse inattendu du service de commande'
    };

  } catch (error) {
    console.error('‚ùå Error creating order:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Erreur inconnue'
    };
  }
}

  // ‚úÖ CR√âER MESSAGE D'UPSELL avec cartes produits
  private async createUpsellMessage(currentProductId: string): Promise<ChatMessage> {
    try {
      // R√©cup√©rer d'autres jeux pour l'upsell
      const { data: relatedProducts } = await supabase
        .from('products')
        .select('id, name, price, images, stats')
        .eq('status', 'active')
        .neq('id', currentProductId)
        .limit(3);

      if (!relatedProducts || relatedProducts.length === 0) {
        return {
          type: 'assistant',
          content: `üõçÔ∏è **Nos autres jeux seront bient√¥t disponibles !**

En attendant, t√©l√©chargez notre app mobile pour d√©couvrir tous nos jeux :`,
          choices: [
            'üì± T√©l√©charger l\'app',
            '‚úÖ Merci, c\'est tout'
          ],
          assistant: { name: 'Rose', title: 'Assistante d\'achat' },
          metadata: {
            nextStep: 'app_recommendation' as ConversationStep
          },
          timestamp: new Date().toISOString()
        };
      }

      // ‚úÖ NOUVEAU: Ajouter les donn√©es produits pour affichage en cartes
      const productCards = relatedProducts.map(p => ({
        id: p.id,
        name: p.name,
        price: p.price,
        images: p.images || [],
        stats: p.stats,
        reason: `Parfait pour compl√©ter votre collection`,
        urgency: 'medium' as const,
        discount: 10 // 10% de r√©duction pour l'upsell
      }));

      return {
        type: 'assistant',
        content: `üõçÔ∏è **Nos autres jeux populaires :**

Profitez de 10% de r√©duction sur votre prochain achat !`,
        choices: [
          ...relatedProducts.map(p => `Ajouter ${p.name}`),
          'Non merci, √ßa suffit'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'upsell_selection' as ConversationStep,
          recommendedProducts: productCards, // ‚úÖ Pour affichage en cartes
          relatedProducts: relatedProducts
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Error creating upsell message:', error);
      return this.createErrorMessage('Impossible de charger les autres jeux.');
    }
  }

  // ‚úÖ M√âTHODES UTILITAIRES
  private isWelcomeButtonChoice(message: string): boolean {
    const welcomeChoices = [
      'je veux l\'acheter maintenant',
      'j\'ai des questions √† poser',
      'je veux en savoir plus'
    ];
    
    return welcomeChoices.some(choice => 
      message.toLowerCase().includes(choice.toLowerCase())
    );
  }


  private isPredefinedQuestion(message: string): boolean {
    const predefinedQuestions = [
      'comment y jouer',
      'c\'est pour qui',
      'quels sont les b√©n√©fices',
      't√©l√©charger l\'application',
      'livraison'
    ];
    
    return predefinedQuestions.some(question => 
      message.toLowerCase().includes(question.toLowerCase())
    );
  }

  private async getProductData(productId: string): Promise<{ price: number }> {
    try {
      const { data: product } = await supabase
        .from('products')
        .select('price')
        .eq('id', productId)
        .single();

      return { price: product?.price || 14000 };
    } catch (error) {
      console.error('Error fetching product data:', error);
      return { price: 14000 }; // Prix par d√©faut
    }
  }

  private getPaymentInstructions(paymentMethod: PaymentProvider): string {
    switch (paymentMethod) {
      case 'wave':
        return 'üì± **Paiement Wave :** Lien de paiement trait√© automatiquement';
      case 'card':
        return 'üí≥ **Carte bancaire :** Paiement s√©curis√© trait√© automatiquement';
      case 'CASH':
        return 'üíµ **Paiement √† la livraison :** Pr√©parez le montant exact';
      default:
        return 'üí≥ **Paiement :** Instructions envoy√©es par SMS';
    }
  }

  private createErrorMessage(errorText: string): ChatMessage {
    return {
      type: 'assistant',
      content: `üòî **${errorText}**

Voulez-vous r√©essayer ou contacter notre support ?`,
      choices: ['üîÑ R√©essayer', 'üìû Contacter le support'],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'error_recovery' as ConversationStep,
        flags: { hasError: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ M√âTHODES PUBLIQUES pour compatibilit√© avec l'existant (CORRIG√âES)
  public async handleExpressFlow(
    sessionId: string,
    message: string,
    currentStep: string
  ): Promise<ChatMessage> {
    // ‚úÖ CORRECTION: Rediriger vers processMessage avec param√®tres complets
    const orderState = this.orderStates.get(sessionId);
    const productId = orderState?.data.productId || '';
    const productName = orderState?.data.productName || '';
    
    return this.processMessage(
      sessionId, 
      message, 
      currentStep as ConversationStep, 
      productId, 
      productName
    );
  }

  public async handleExpressStep(
    sessionId: string,
    input: string,
    currentStep: string
  ): Promise<ChatMessage> {
    // ‚úÖ CORRECTION: Rediriger vers processMessage avec param√®tres complets
    const orderState = this.orderStates.get(sessionId);
    const productId = orderState?.data.productId || '';
    const productName = orderState?.data.productName || '';
    
    return this.processMessage(
      sessionId, 
      input, 
      currentStep as ConversationStep, 
      productId, 
      productName
    );
  }
}