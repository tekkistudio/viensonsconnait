// src/lib/services/OptimizedChatService.ts - VERSION CORRIG√âE AVEC PAIEMENT FONCTIONNEL

import { supabase } from '@/lib/supabase';
import type { 
  ChatMessage, 
  ConversationStep, 
  ChatOrderData,
  PaymentProvider,
  ProductData
} from '@/types/chat';
import { WelcomeMessageService } from './WelcomeMessageService';

// Types pour le flow express
interface ExpressOrderState {
  step: 'quantity' | 'phone' | 'name' | 'address' | 'payment' | 'confirmation';
  data: {
    productId: string;
    productName: string;
    unitPrice: number;
    quantity: number;
    phone?: string;
    firstName?: string;
    lastName?: string;
    city?: string;
    address?: string;
    paymentMethod?: PaymentProvider;
  };
  flags: {
    isExistingCustomer: boolean;
    needsNameCollection: boolean;
    needsAddressCollection: boolean;
  };
  sessionId: string;
  createdAt: string;
  updatedAt: string;
}

export class OptimizedChatService {
  private static instance: OptimizedChatService;
  private orderStates = new Map<string, ExpressOrderState>();
  private welcomeService = WelcomeMessageService.getInstance();

  private constructor() {
    console.log('üîß OptimizedChatService v5.1 initialized (Wave Payment Fixed)');
  }

  public static getInstance(): OptimizedChatService {
    if (!this.instance) {
      this.instance = new OptimizedChatService();
    }
    return this.instance;
  }

  // ‚úÖ M√âTHODE PRINCIPALE COMPATIBLE AVEC L'API
  public async processMessage(
    sessionId: string,
    message: string,
    currentStep: ConversationStep,
    productId: string,
    productName: string
  ): Promise<ChatMessage> {
    try {
      console.log('üîç ProcessMessage called with:', {
        sessionId: sessionId?.substring(0, 20) + '...',
        message: message?.substring(0, 50) + '...',
        currentStep,
        productId,
        productName
      });

      // V√©rifications de s√©curit√©
      if (!sessionId || !productId || !productName) {
        throw new Error('Param√®tres manquants');
      }

      // ‚úÖ Toujours essayer de r√©cup√©rer l'√©tat depuis la base
      await this.loadOrderStateFromDatabase(sessionId);

      // ‚úÖ GESTION PRIORITAIRE: "Je veux l'acheter maintenant"
      if (this.isExpressPurchaseTrigger(message)) {
        console.log('üõí Express purchase detected');
        return await this.startExpressPurchase(sessionId, productId, productName);
      }

      // ‚úÖ G√©rer le flow express (√©tapes sc√©naris√©es) 
      if (currentStep.startsWith('express_') || this.orderStates.has(sessionId)) {
        console.log('üì¶ Express flow step detected');
        return await this.handleExpressFlowInternal(sessionId, message, currentStep, productId, productName);
      }

      // ‚úÖ G√©rer les autres boutons du message d'accueil
      if (this.isWelcomeButtonChoice(message)) {
        console.log('üåπ Welcome button choice detected');
        return await this.welcomeService.handleWelcomeButtonResponse(message, productId, productName);
      }

      // ‚úÖ G√©rer les questions pr√©d√©finies
      if (this.isPredefinedQuestion(message)) {
        console.log('üìã Predefined question detected');
        return await this.handlePredefinedQuestion(message, productId, productName);
      }

      // ‚úÖ Questions libres ‚Üí R√©ponse simple
      console.log('ü§ñ Free text question detected');
      return await this.handleFreeTextQuestion(message, productId, productName, sessionId);

    } catch (error) {
      console.error('‚ùå Error in processMessage:', error);
      return this.createErrorMessage(`Erreur: ${error instanceof Error ? error.message : 'Inconnue'}`);
    }
  }

  // ‚úÖ CORRECTION: Charger l'√©tat depuis la base de donn√©es
  private async loadOrderStateFromDatabase(sessionId: string): Promise<void> {
    try {
      if (this.orderStates.has(sessionId)) {
        console.log('üìã Order state already in memory');
        return;
      }

      const { data: session, error } = await supabase
        .from('chat_sessions')
        .select('*')
        .eq('session_id', sessionId)
        .maybeSingle();

      if (error) {
        console.error('‚ùå Error loading session:', error);
        return;
      }

      if (session && session.order_state) {
        const orderState = session.order_state as ExpressOrderState;
        this.orderStates.set(sessionId, orderState);
        console.log('‚úÖ Order state loaded from database:', orderState.step);
      }
    } catch (error) {
      console.error('‚ùå Error in loadOrderStateFromDatabase:', error);
    }
  }

  // ‚úÖ CORRECTION: Sauvegarder l'√©tat en base de donn√©es
  private async saveOrderStateToDatabase(sessionId: string, orderState: ExpressOrderState): Promise<void> {
    try {
      const sessionData = {
        session_id: sessionId,
        product_id: orderState.data.productId,
        order_state: orderState,
        current_step: orderState.step,
        updated_at: new Date().toISOString()
      };

      const { error } = await supabase
        .from('chat_sessions')
        .upsert(sessionData, { onConflict: 'session_id' });

      if (error) {
        console.error('‚ùå Error saving session:', error);
      } else {
        console.log('‚úÖ Session saved to database');
      }
    } catch (error) {
      console.error('‚ùå Error in saveOrderStateToDatabase:', error);
    }
  }

  // ‚úÖ D√âTECTER LES TRIGGERS D'ACHAT EXPRESS
  private isExpressPurchaseTrigger(message: string): boolean {
    const triggers = [
      'Je veux l\'acheter maintenant',
      'acheter maintenant',
      'commander maintenant',
      'Je veux l\'acheter',
      '‚ö° Commander rapidement',
      'Commander rapidement'
    ];
    
    return triggers.some(trigger => 
      message.toLowerCase().includes(trigger.toLowerCase())
    );
  }

  // ‚úÖ D√âMARRER L'ACHAT EXPRESS AVEC PLUS DE FLUIDIT√â
  public async startExpressPurchase(
    sessionId: string,
    productId: string,
    productName?: string
  ): Promise<ChatMessage> {
    try {
      console.log('üöÄ startExpressPurchase called');

      // R√©cup√©rer les informations du produit
      const { data: product, error } = await supabase
        .from('products')
        .select('name, price')
        .eq('id', productId)
        .single();

      if (error || !product) {
        throw new Error('Produit non trouv√© en base');
      }

      // ‚úÖ Nettoyer l'ancienne session si elle existe
      if (this.orderStates.has(sessionId)) {
        this.orderStates.delete(sessionId);
      }

      // Initialiser l'√©tat de commande express
      const orderState: ExpressOrderState = {
        step: 'quantity',
        data: {
          productId,
          productName: productName || product.name,
          unitPrice: product.price,
          quantity: 1
        },
        flags: {
          isExistingCustomer: false,
          needsNameCollection: true,
          needsAddressCollection: true
        },
        sessionId: sessionId,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      // ‚úÖ Sauvegarder en m√©moire ET en base
      this.orderStates.set(sessionId, orderState);
      await this.saveOrderStateToDatabase(sessionId, orderState);

      console.log('‚úÖ Order state created and saved');

      return {
        type: 'assistant' as const,
        content: `üõí **Parfait ! Je vais vous aider √† commander votre ${productName || product.name}**

C'est un excellent choix ! üéâ

Pour commencer, combien d'exemplaires souhaitez-vous ?`,
        choices: [
          '1 exemplaire',
          '2 exemplaires',
          '3 exemplaires', 
          'Autre quantit√©'
        ],
        assistant: {
          name: 'Rose',
          title: 'Assistante d\'achat'
        },
        metadata: {
          nextStep: 'express_quantity' as ConversationStep,
          productId: productId,
          flags: { 
            expressMode: true,
            quantitySelection: true
          }
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Error in startExpressPurchase:', error);
      return this.createErrorMessage(`Erreur achat express: ${error instanceof Error ? error.message : 'Inconnue'}`);
    }
  }

  // ‚úÖ GESTION INTERNE DU FLOW EXPRESS AVEC PLUS DE FLUIDIT√â
  private async handleExpressFlowInternal(
    sessionId: string,
    message: string,
    currentStep: ConversationStep,
    productId: string,
    productName: string
  ): Promise<ChatMessage> {
    try {
      // ‚úÖ Toujours charger depuis la base si pas en m√©moire
      await this.loadOrderStateFromDatabase(sessionId);
      
      let orderState = this.orderStates.get(sessionId);
      
      // Initialiser l'√©tat si premi√®re fois
      if (!orderState && currentStep === 'express_quantity') {
        const product = await this.getProductData(productId);
        orderState = {
          step: 'quantity',
          data: {
            productId,
            productName,
            unitPrice: product.price,
            quantity: 1
          },
          flags: {
            isExistingCustomer: false,
            needsNameCollection: true,
            needsAddressCollection: true
          },
          sessionId: sessionId,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        };
        this.orderStates.set(sessionId, orderState);
        await this.saveOrderStateToDatabase(sessionId, orderState);
      }

      if (!orderState) {
        return this.createErrorMessage('Session expir√©e. Veuillez recommencer votre commande.');
      }

      // Router selon l'√©tape
      switch (orderState.step) {
        case 'quantity':
          return await this.handleQuantityStepFluid(sessionId, message, orderState);
        case 'phone':
          return await this.handlePhoneStepFluid(sessionId, message, orderState);
        case 'name':
          return await this.handleNameStepFluid(sessionId, message, orderState);
        case 'address':
          return await this.handleAddressStepFluid(sessionId, message, orderState);
        case 'payment':
          return await this.handlePaymentStepFluid(sessionId, message, orderState);
        case 'confirmation':
          return await this.handleConfirmationStep(sessionId, message, orderState);
        default:
          return this.createErrorMessage('√âtape inconnue dans la commande express.');
      }

    } catch (error) {
      console.error('‚ùå Error in express flow:', error);
      return this.createErrorMessage('Erreur dans le processus de commande');
    }
  }

  // ‚úÖ √âTAPE 1 : Quantit√© PLUS FLUIDE
  private async handleQuantityStepFluid(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    let quantity = 1;

    // Parser la quantit√©
    if (message.includes('1 exemplaire')) quantity = 1;
    else if (message.includes('2 exemplaires')) quantity = 2;
    else if (message.includes('3 exemplaires')) quantity = 3;
    else if (message.includes('Autre quantit√©')) {
      return {
        type: 'assistant',
        content: `üî¢ **Quantit√© personnalis√©e**

Combien d'exemplaires de **${orderState.data.productName}** souhaitez-vous ?

*Tapez simplement le nombre (entre 1 et 10)*`,
        choices: [],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_custom_quantity' as ConversationStep,
          flags: { awaitingNumericInput: true }
        },
        timestamp: new Date().toISOString()
      };
    } else {
      // Essayer de parser un nombre
      const numMatch = message.match(/(\d+)/);
      if (numMatch) {
        quantity = parseInt(numMatch[1]);
        if (quantity < 1 || quantity > 10) {
          return this.createErrorMessage('Veuillez choisir une quantit√© entre 1 et 10.');
        }
      } else {
        return this.createErrorMessage('Veuillez s√©lectionner une quantit√© valide.');
      }
    }

    // ‚úÖ Mettre √† jour l'√©tat et sauvegarder
    orderState.data.quantity = quantity;
    orderState.step = 'phone';
    orderState.updatedAt = new Date().toISOString();
    
    this.orderStates.set(sessionId, orderState);
    await this.saveOrderStateToDatabase(sessionId, orderState);

    const totalAmount = orderState.data.unitPrice * quantity;

    return {
      type: 'assistant',
      content: `‚úÖ **C'est not√© ! Vous commandez ${quantity} exemplaire${quantity > 1 ? 's' : ''} du jeu ${orderState.data.productName}**

**Prix total :** ${totalAmount.toLocaleString()} FCFA

Parfait ! Maintenant, j'ai besoin de votre num√©ro de t√©l√©phone pour organiser la livraison üì±

*Exemple : +221 77 123 45 67*`,
      choices: [],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'express_phone' as ConversationStep,
        orderData: {
          productId: orderState.data.productId,
          productName: orderState.data.productName,
          quantity: quantity,
          unitPrice: orderState.data.unitPrice,
          totalAmount: totalAmount,
          session_id: sessionId
        },
        flags: { awaitingPhoneInput: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ √âTAPE 2 : T√©l√©phone PLUS FLUIDE
  private async handlePhoneStepFluid(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    // Validation simple du t√©l√©phone
    const cleanPhone = message.replace(/\s/g, '');
    if (cleanPhone.length < 8) {
      return {
        type: 'assistant',
        content: `üòÖ **Ce num√©ro me semble un peu court**

Pouvez-vous me donner votre num√©ro complet s'il vous pla√Æt ?

*Format : +221 77 123 45 67*`,
        choices: [],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_phone' as ConversationStep,
          flags: { phoneError: true }
        },
        timestamp: new Date().toISOString()
      };
    }

    // Formater le t√©l√©phone
    let formattedPhone = cleanPhone;
    if (!formattedPhone.startsWith('+')) {
      formattedPhone = '+221' + formattedPhone;
    }
    
    // ‚úÖ Mettre √† jour et sauvegarder
    orderState.data.phone = formattedPhone;
    orderState.updatedAt = new Date().toISOString();

    // V√©rifier si client existant
    const { data: existingCustomer } = await supabase
      .from('customers')
      .select('first_name, last_name, city, address')
      .eq('phone', formattedPhone)
      .maybeSingle();

    if (existingCustomer) {
      // Client existant
      orderState.data.firstName = existingCustomer.first_name;
      orderState.data.lastName = existingCustomer.last_name;
      orderState.data.city = existingCustomer.city;
      orderState.data.address = existingCustomer.address;
      orderState.flags.isExistingCustomer = true;
      orderState.flags.needsNameCollection = false;
      orderState.flags.needsAddressCollection = false;
      orderState.step = 'address'; // Pour confirmation d'adresse
      
      this.orderStates.set(sessionId, orderState);
      await this.saveOrderStateToDatabase(sessionId, orderState);

      return {
        type: 'assistant',
        content: `üëã **Oh ! Ravi de vous revoir ${existingCustomer.first_name} !**

J'ai retrouv√© vos informations dans notre syst√®me üòä

üìç **Votre adresse habituelle :** ${existingCustomer.address}, ${existingCustomer.city}

Souhaitez-vous qu'on vous livre √† cette m√™me adresse ?`,
        choices: [
          'Oui, m√™me adresse',
          'Changer d\'adresse'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_address_confirmation' as ConversationStep,
          flags: { existingCustomer: true }
        },
        timestamp: new Date().toISOString()
      };
    } else {
      // Nouveau client
      orderState.step = 'name';
      this.orderStates.set(sessionId, orderState);
      await this.saveOrderStateToDatabase(sessionId, orderState);

      return {
        type: 'assistant',
        content: `üì± **Parfait ! ${formattedPhone} enregistr√©**

Je vois que c'est votre premi√®re commande chez nous. Bienvenue ! üéâ

Pour finaliser, quel est votre nom complet ?

*Exemple : Amadou Diallo*`,
        choices: [],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_name' as ConversationStep,
          flags: { awaitingNameInput: true, newCustomer: true }
        },
        timestamp: new Date().toISOString()
      };
    }
  }

  // ‚úÖ √âTAPE 3 : Nom PLUS FLUIDE
  private async handleNameStepFluid(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    const name = message.trim();
    
    if (name.length < 2) {
      return this.createErrorMessage('Le nom doit contenir au moins 2 caract√®res.');
    }

    const parts = name.split(/\s+/);
    if (parts.length < 2) {
      return {
        type: 'assistant',
        content: `üòÖ **J'ai besoin de votre nom complet**

Pouvez-vous me donner votre pr√©nom ET votre nom s'il vous pla√Æt ?

*Exemple : Amadou Diallo*`,
        choices: [],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_name' as ConversationStep,
          flags: { nameError: true }
        },
        timestamp: new Date().toISOString()
      };
    }

    // ‚úÖ Mettre √† jour et sauvegarder
    orderState.data.firstName = parts[0];
    orderState.data.lastName = parts.slice(1).join(' ');
    orderState.step = 'address';
    orderState.updatedAt = new Date().toISOString();
    
    this.orderStates.set(sessionId, orderState);
    await this.saveOrderStateToDatabase(sessionId, orderState);

    return {
      type: 'assistant',
      content: `üë§ **Enchant√© de vous conna√Ætre ${orderState.data.firstName} !**

Il ne me reste plus qu'√† conna√Ætre votre adresse de livraison pour qu'on puisse vous apporter votre jeu üöö

*Format recommand√© : Quartier/Rue, Ville*
*Exemple : Cit√© Keur Gorgui, Villa 123, Dakar*`,
      choices: [],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'express_address' as ConversationStep,
        flags: { awaitingAddressInput: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ √âTAPE 4 : Adresse PLUS FLUIDE
  private async handleAddressStepFluid(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    console.log('üè† Processing address step:', message);
    
    // ‚úÖ Reconna√Ætre toutes les variantes de confirmation
    const confirmationMessages = [
      'oui, m√™me adresse',
      'oui m√™me adresse', 
      'm√™me adresse',
      'oui',
      'confirmer',
      'garder la m√™me',
      'conserver l\'adresse',
      'garder cette adresse',
      'utiliser la m√™me'
    ];
    
    const isAddressConfirmation = confirmationMessages.some(phrase => 
      message.toLowerCase().includes(phrase.toLowerCase())
    );

    // ‚úÖ V√©rifier si c'est une confirmation ET client existant
    if (isAddressConfirmation && orderState.flags.isExistingCustomer) {
      console.log('‚úÖ Address confirmed for existing customer');
      
      // ‚úÖ Mettre √† jour et sauvegarder
      orderState.step = 'payment';
      orderState.updatedAt = new Date().toISOString();
      this.orderStates.set(sessionId, orderState);
      await this.saveOrderStateToDatabase(sessionId, orderState);

      const totalAmount = orderState.data.unitPrice * orderState.data.quantity;

      return {
        type: 'assistant',
        content: `‚úÖ **Parfait ! Livraison confirm√©e √† votre adresse habituelle**

üìç **Adresse :** ${orderState.data.address}, ${orderState.data.city}

üí∞ **R√©capitulatif de votre commande :**
‚Ä¢ ${orderState.data.quantity}x ${orderState.data.productName}
‚Ä¢ **Total : ${totalAmount.toLocaleString()} FCFA**

üéØ **Derni√®re √©tape : Comment souhaitez-vous payer ?**`,
        choices: [
          'üì± Wave (recommand√©)',
          'üí≥ Carte bancaire', 
          'üíµ Paiement √† la livraison'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_payment' as ConversationStep,
          orderData: orderState.data,
          flags: { addressConfirmed: true }
        },
        timestamp: new Date().toISOString()
      };
    }

    // Reconna√Ætre "Changer d'adresse"
    const changeAddressMessages = [
      'changer d\'adresse',
      'changer adresse',
      'nouvelle adresse',
      'autre adresse',
      'modifier',
      'diff√©rente'
    ];
    
    const isAddressChange = changeAddressMessages.some(phrase => 
      message.toLowerCase().includes(phrase.toLowerCase())
    );

    if (isAddressChange) {
      return {
        type: 'assistant',
        content: `üìç **Pas de probl√®me ! Donnez-moi votre nouvelle adresse**

O√π souhaitez-vous qu'on vous livre votre jeu ?

**Format :** Quartier/Rue, Ville
**Exemple :** Mermoz, Dakar`,
        choices: [],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_address' as ConversationStep,
          flags: { 
            collectingNewAddress: true,
            addressChangeRequested: true 
          }
        },
        timestamp: new Date().toISOString()
      };
    }

    // Traiter une nouvelle adresse saisie
    if (message.trim().length > 5) {
      const addressParts = message.split(',').map(part => part.trim());
      
      if (addressParts.length >= 2) {
        // Format: "Rue/Quartier, Ville"
        orderState.data.address = addressParts[0];
        orderState.data.city = addressParts[1];
      } else {
        // Une seule partie - consid√©rer comme adresse, garder la ville existante
        orderState.data.address = message.trim();
        if (!orderState.data.city) {
          orderState.data.city = 'Dakar'; // Valeur par d√©faut
        }
      }

      // ‚úÖ Mettre √† jour et sauvegarder
      orderState.step = 'payment';
      orderState.updatedAt = new Date().toISOString();
      this.orderStates.set(sessionId, orderState);
      await this.saveOrderStateToDatabase(sessionId, orderState);

      const totalAmount = orderState.data.unitPrice * orderState.data.quantity;

      return {
        type: 'assistant',
        content: `‚úÖ **Adresse enregistr√©e avec succ√®s !**

üìç **Livraison confirm√©e √† :** ${orderState.data.address}, ${orderState.data.city}

üí∞ **R√©capitulatif de votre commande :**
‚Ä¢ ${orderState.data.quantity}x ${orderState.data.productName}
‚Ä¢ **Total : ${totalAmount.toLocaleString()} FCFA**

üéØ **Plus qu'un clic ! Comment souhaitez-vous r√©gler ?**`,
        choices: [
          'üì± Wave (recommand√©)',
          'üí≥ Carte bancaire', 
          'üíµ Paiement √† la livraison'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_payment' as ConversationStep,
          orderData: orderState.data,
          flags: { 
            addressUpdated: true,
            newAddressSet: true 
          }
        },
        timestamp: new Date().toISOString()
      };
    }

    // Message d'erreur si le format n'est pas reconnu
    return {
      type: 'assistant',
      content: `üòÖ **Je n'ai pas bien saisi votre choix**

Pouvez-vous m'aider ? Voulez-vous :

‚Ä¢ **Garder votre adresse actuelle** : ${orderState.data.address || 'Non d√©finie'}, ${orderState.data.city || 'Non d√©finie'}
‚Ä¢ **Ou bien saisir une nouvelle adresse** ?

Vous pouvez aussi taper directement votre adresse compl√®te (Quartier, Ville)`,
      choices: [
        'Oui, m√™me adresse',
        'Changer d\'adresse'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'express_address' as ConversationStep,
        flags: { 
          addressConfirmationPending: true,
          retryAddressStep: true 
        }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ √âTAPE 5 : Paiement CORRIG√â AVEC V√âRIFICATION WAVE MANUELLE
  private async handlePaymentStepFluid(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    // ‚úÖ NOUVEAU: V√©rifier si c'est un ID de transaction Wave
    if (this.isWaveTransactionId(message)) {
      return await this.handleWaveTransactionVerification(sessionId, message, orderState);
    }
    
    let paymentMethod: PaymentProvider;

    if (message.toLowerCase().includes('wave')) {
      paymentMethod = 'wave';
    } else if (message.toLowerCase().includes('carte')) {
      paymentMethod = 'card';
    } else if (message.toLowerCase().includes('livraison')) {
      paymentMethod = 'cash_on_delivery';
    } else if (message === 'WAVE_PAYMENT_INITIATED') {
      // ‚úÖ NOUVEAU: Gestion du retour Wave
      return await this.handleWavePaymentReturn(sessionId, orderState);
    } else {
      return {
        type: 'assistant',
        content: `üòÖ **Je n'ai pas bien compris votre choix de paiement**

Pouvez-vous choisir parmi ces options ?`,
        choices: [
          'üì± Wave (recommand√©)',
          'üí≥ Carte bancaire', 
          'üíµ Paiement √† la livraison'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_payment' as ConversationStep,
          flags: { paymentError: true }
        },
        timestamp: new Date().toISOString()
      };
    }

    // ‚úÖ Mettre √† jour et sauvegarder
    orderState.data.paymentMethod = paymentMethod;
    orderState.updatedAt = new Date().toISOString();
    this.orderStates.set(sessionId, orderState);
    await this.saveOrderStateToDatabase(sessionId, orderState);

    if (paymentMethod === 'wave') {
      // ‚úÖ WAVE: Cr√©er la commande mais en statut pending
      const orderResult = await this.createOrderCorrected(sessionId, orderState, 'pending');
      
      if (!orderResult.success) {
        return this.createErrorMessage(orderResult.error || 'Erreur lors de la cr√©ation de la commande');
      }

      // ‚úÖ NOUVEAU: Message pour Wave avec instructions sp√©ciales
      const totalAmount = orderState.data.unitPrice * orderState.data.quantity;
      
      return {
        type: 'assistant',
        content: `üåä **Paiement Wave s√©lectionn√©**

**Commande :** #${orderResult.orderId}
**Montant :** ${totalAmount.toLocaleString()} FCFA

üîó **Cliquez sur le bouton Wave ci-dessous pour payer**

Apr√®s votre paiement, revenez ici et donnez-moi votre **ID de Transaction** Wave pour confirmer votre commande.

üí° **L'ID de Transaction se trouve dans votre historique Wave et commence par 'T'**`,
        choices: [
          'üåä Payer avec Wave'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'wave_payment_pending' as ConversationStep,
          orderData: {
            orderId: orderResult.orderId,
            paymentMethod: paymentMethod,
            totalAmount: totalAmount,
            status: 'pending'
          },
          paymentAmount: totalAmount,
          flags: { 
            wavePaymentMode: true,
            awaitingPayment: true
          }
        },
        timestamp: new Date().toISOString()
      };
    }

    // ‚úÖ Pour carte et livraison : flux normal
    orderState.step = 'confirmation';
    this.orderStates.set(sessionId, orderState);
    await this.saveOrderStateToDatabase(sessionId, orderState);

    const orderResult = await this.createOrderCorrected(sessionId, orderState);
    
    if (!orderResult.success) {
      return this.createErrorMessage(orderResult.error || 'Erreur lors de la cr√©ation de la commande');
    }

    // Personnaliser le message selon le mode de paiement
    let paymentInstructions = '';
    if (paymentMethod === 'card') {
      paymentInstructions = `üí≥ **Carte bancaire** : Vous allez √™tre redirig√© vers une page de paiement s√©curis√©e.`;
    } else {
      paymentInstructions = `üíµ **Paiement √† la livraison** : Pr√©parez le montant exact pour le livreur.`;
    }

    return {
      type: 'assistant',
      content: `üéâ **F√©licitations ! Votre commande est confirm√©e !**

**Num√©ro de commande :** #${orderResult.orderId}

${paymentInstructions}

**D√©tails de livraison :**
üìç ${orderState.data.address}, ${orderState.data.city}
‚è∞ Livraison sous 24-48h ouvrables
üìû Nous vous tiendrons inform√©(e) par SMS

Merci pour votre confiance ! üôè`,
      choices: [
        'üì± Recevoir confirmations par SMS',
        '‚úÖ Parfait, merci !',
        'üõçÔ∏è Commander un autre jeu'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'express_completed' as ConversationStep,
        orderData: {
          orderId: orderResult.orderId,
          paymentMethod: paymentMethod,
          status: 'confirmed'
        },
        flags: { orderCompleted: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ NOUVEAU: V√©rifier si c'est un ID de transaction Wave
  private isWaveTransactionId(message: string): boolean {
    const cleanMessage = message.trim().toUpperCase();
    // Les IDs Wave commencent par 'T' et font 10-16 caract√®res alphanum√©riques
    const waveIdPattern = /^T[A-Z0-9]{10,15}$/;
    return waveIdPattern.test(cleanMessage);
  }

  // ‚úÖ NOUVEAU: G√©rer le retour du paiement Wave
  private async handleWavePaymentReturn(
    sessionId: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    const totalAmount = orderState.data.unitPrice * orderState.data.quantity;
    
    return {
      type: 'assistant',
      content: `‚úÖ **Retour du paiement Wave**

J'esp√®re que votre paiement s'est bien pass√© ! 

Pour confirmer votre commande, donnez-moi votre **ID de Transaction Wave**.

üí° **Comment le trouver :**
1. Ouvrez votre app Wave
2. Allez dans l'historique des transactions
3. Trouvez le paiement de ${totalAmount.toLocaleString()} FCFA
4. Copiez l'ID de Transaction (commence par 'T')

*Exemple : TJJDJORO4EPQAR4FD*`,
      choices: [],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'wave_transaction_verification' as ConversationStep,
        flags: { 
          awaitingWaveTransactionId: true,
          wavePaymentMode: true
        }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ NOUVEAU: V√©rifier l'ID de transaction Wave
  private async handleWaveTransactionVerification(
    sessionId: string,
    transactionId: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    const cleanTransactionId = transactionId.trim().toUpperCase();
    
    if (!this.isWaveTransactionId(cleanTransactionId)) {
      return {
        type: 'assistant',
        content: `‚ùå **ID de Transaction invalide**

L'ID de Transaction Wave doit :
‚Ä¢ Commencer par la lettre 'T'
‚Ä¢ Contenir entre 10 et 15 caract√®res
‚Ä¢ Exemple : TJJDJORO4EPQAR4FD

Veuillez v√©rifier et r√©essayer.`,
        choices: [
          'üîÑ R√©essayer',
          'üìû Contacter le support'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'wave_transaction_verification' as ConversationStep,
          flags: { 
            transactionIdError: true,
            awaitingWaveTransactionId: true
          }
        },
        timestamp: new Date().toISOString()
      };
    }

    // ‚úÖ Mettre √† jour la commande avec l'ID de transaction
    try {
      const { error } = await supabase
        .from('orders')
        .update({
          payment_status: 'completed',
          status: 'confirmed',
          metadata: JSON.stringify({
            source: 'chatbot_express',
            wave_transaction_id: cleanTransactionId,
            payment_verified_at: new Date().toISOString()
          }),
          updated_at: new Date().toISOString()
        })
        .eq('session_id', sessionId);

      if (error) {
        console.error('‚ùå Error updating order with Wave transaction:', error);
        return this.createErrorMessage('Erreur lors de la mise √† jour de la commande');
      }

      // ‚úÖ Nettoyer l'√©tat
      orderState.step = 'confirmation';
      this.orderStates.set(sessionId, orderState);
      await this.saveOrderStateToDatabase(sessionId, orderState);

      return {
        type: 'assistant',
        content: `üéâ **Paiement Wave confirm√© !**

‚úÖ **Transaction v√©rifi√©e :** ${cleanTransactionId}
‚úÖ **Votre commande est maintenant confirm√©e**

**D√©tails de livraison :**
üìç ${orderState.data.address}, ${orderState.data.city}
‚è∞ Livraison sous 24-48h ouvrables
üìû Nous vous tiendrons inform√©(e) par SMS

üôè **Merci pour votre confiance en VIENS ON S'CONNA√éT !**`,
        choices: [
          'üì± Recevoir confirmations par SMS',
          '‚≠ê Laisser un avis',
          'üõçÔ∏è Commander un autre jeu'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'express_completed' as ConversationStep,
          orderData: {
            paymentMethod: 'wave',
            transactionId: cleanTransactionId,
            status: 'confirmed'
          },
          flags: { 
            orderCompleted: true,
            paymentConfirmed: true,
            waveVerified: true
          }
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Error in Wave transaction verification:', error);
      return this.createErrorMessage('Erreur lors de la v√©rification du paiement Wave');
    }
  }

  // ‚úÖ CORRECTION MAJEURE : Cr√©er une commande avec le BON SCH√âMA et gestion statut
  private async createOrderCorrected(
    sessionId: string,
    orderState: ExpressOrderState,
    orderStatus: string = 'pending'
  ): Promise<{ success: boolean; orderId?: string; error?: string }> {
    try {
      console.log('üì¶ Creating order with CORRECTED schema and status:', orderStatus);

      // ‚úÖ CORRECTION CRITIQUE: G√©n√©rer un ID court uniquement num√©rique pour √©viter bigint error
      const timestamp = Date.now();
      const random = Math.floor(Math.random() * 1000);
      const orderId = `${timestamp}${random}`; // ID purement num√©rique comme string
      
      // ‚úÖ SCH√âMA CORRIG√â : Utiliser les bons noms de colonnes et types
      const orderData = {
        id: orderId, // String num√©rique pour compatibilit√©
        session_id: sessionId,
        product_id: orderState.data.productId,
        customer_name: `${orderState.data.firstName || 'Client'} ${orderState.data.lastName || ''}`.trim(),
        first_name: orderState.data.firstName || 'Client',
        last_name: orderState.data.lastName || '',
        phone: orderState.data.phone || '',
        city: orderState.data.city || '',
        address: orderState.data.address || '',
        payment_method: orderState.data.paymentMethod || 'cash_on_delivery',
        
        // ‚úÖ CORRECTION CRITIQUE : Utiliser 'status' au lieu de 'order_status'
        status: orderStatus, // 'pending', 'confirmed', etc.
        payment_status: orderStatus === 'pending' ? 'pending' : 'completed',
        
        // ‚úÖ CORRECTION: S'assurer que les montants sont des nombres
        total_amount: Number(orderState.data.unitPrice * orderState.data.quantity),
        delivery_cost: 0,
        
        // ‚úÖ Stocker les d√©tails dans order_details comme JSON string
        order_details: JSON.stringify([{
          product_id: orderState.data.productId,
          product_name: orderState.data.productName,
          quantity: Number(orderState.data.quantity),
          unit_price: Number(orderState.data.unitPrice),
          total_price: Number(orderState.data.unitPrice * orderState.data.quantity)
        }]),
        
        metadata: JSON.stringify({
          source: 'chatbot_express',
          flow: 'express',
          session_id: sessionId,
          created_via: 'chat_conversation',
          payment_method: orderState.data.paymentMethod,
          order_status: orderStatus
        }),
        
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      console.log('üìã Order data prepared with corrected schema:', {
        id: orderData.id,
        status: orderData.status,
        payment_status: orderData.payment_status,
        total_amount: orderData.total_amount,
        id_type: typeof orderData.id
      });

      // ‚úÖ Ins√©rer dans la base de donn√©es
      const { data, error } = await supabase
        .from('orders')
        .insert(orderData)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Database error CORRECTED:', {
          error: error.message,
          code: error.code,
          details: error.details,
          hint: error.hint
        });
        return {
          success: false,
          error: `Erreur base de donn√©es: ${error.message}`
        };
      }

      console.log('‚úÖ Order created successfully with corrected schema:', data.id);
      
      return {
        success: true,
        orderId: data.id
      };

    } catch (error) {
      console.error('‚ùå Error creating order with corrected schema:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Erreur inconnue'
      };
    }
  }

  // ‚úÖ GESTION DES AUTRES M√âTHODES (inchang√©es)
  public async handleExpressFlow(
    sessionId: string,
    message: string,
    currentStep: ConversationStep | string
  ): Promise<ChatMessage> {
    await this.loadOrderStateFromDatabase(sessionId);
    
    const orderState = this.orderStates.get(sessionId);
    
    if (!orderState) {
      console.log('‚ùå No order state found after loading from DB');
      return this.createErrorMessage('Session de commande expir√©e. Cliquez sur "Je veux l\'acheter maintenant" pour recommencer.');
    }

    return await this.handleExpressFlowInternal(
      sessionId, 
      message, 
      currentStep as ConversationStep, 
      orderState.data.productId, 
      orderState.data.productName
    );
  }

  public async handleExpressStep(
    sessionId: string,
    input: string,
    currentStep: string
  ): Promise<ChatMessage> {
    await this.loadOrderStateFromDatabase(sessionId);
    
    const orderState = this.orderStates.get(sessionId);
    
    if (!orderState) {
      return this.createErrorMessage('Session de commande expir√©e. Veuillez recommencer.');
    }
    
    return this.handleExpressFlowInternal(
      sessionId, 
      input, 
      currentStep as ConversationStep, 
      orderState.data.productId, 
      orderState.data.productName
    );
  }

  // ‚úÖ √âTAPE 6 : Confirmation finale
  private async handleConfirmationStep(
    sessionId: string,
    message: string,
    orderState: ExpressOrderState
  ): Promise<ChatMessage> {
    
    // Nettoyer l'√©tat de commande
    this.orderStates.delete(sessionId);
    
    // Supprimer de la base aussi
    try {
      await supabase
        .from('chat_sessions')
        .delete()
        .eq('session_id', sessionId);
    } catch (error) {
      console.error('‚ùå Error cleaning session:', error);
    }

    if (message.includes('Recevoir confirmations')) {
      return {
        type: 'assistant',
        content: `üì± **SMS de confirmation envoy√© !**

Vous recevrez toutes les mises √† jour de votre commande par SMS.

C'√©tait un plaisir de vous aider ! √Ä bient√¥t chez VIENS ON S'CONNA√éT üéâ`,
        choices: [
          'üõçÔ∏è Voir d\'autres jeux',
          'üì± T√©l√©charger l\'app mobile',
          '‚úÖ Parfait, merci !'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'post_purchase' as ConversationStep,
          flags: { orderCompleted: true, smsRequested: true }
        },
        timestamp: new Date().toISOString()
      };
    }

    if (message.includes('Commander un autre jeu')) {
      return await this.createUpsellMessage(orderState.data.productId);
    }

    return {
      type: 'assistant',
      content: `‚úÖ **Merci infiniment pour votre confiance !**

Votre jeu **${orderState.data.productName}** sera livr√© dans les plus brefs d√©lais.

üéÆ **Profitez bien de cette exp√©rience unique de VIENS ON S'CONNA√éT !**

√Ä tr√®s bient√¥t ! üíï`,
      choices: [
        'üõçÔ∏è Commander un autre jeu',
        'üì± T√©l√©charger l\'app mobile',
        '‚≠ê Laisser un avis'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'post_purchase' as ConversationStep,
        flags: { orderCompleted: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ GESTION DES QUESTIONS PR√âD√âFINIES
  private async handlePredefinedQuestion(
    message: string,
    productId: string,
    productName: string
  ): Promise<ChatMessage> {
    
    if (message.includes('comment y jouer') || message.includes('Comment y jouer')) {
      return {
        type: 'assistant',
        content: `üéÆ **Comment jouer au jeu ${productName} :**

**C'est tr√®s simple :**
1Ô∏è‚É£ **M√©langez** les 150 cartes
2Ô∏è‚É£ **Chacun votre tour**, tirez une carte
3Ô∏è‚É£ **Lisez la question** √† voix haute
4Ô∏è‚É£ **R√©pondez sinc√®rement** et √©coutez la r√©ponse de l'autre
5Ô∏è‚É£ **√âchangez** sur vos r√©ponses respectives

üéØ **L'objectif :** Cr√©er des conversations profondes et authentiques pour mieux vous comprendre !

üí° **Astuce :** Prenez votre temps, il n'y a pas de bonnes ou mauvaises r√©ponses.`,
        choices: [
          'Je veux l\'acheter maintenant',
          'C\'est pour qui ?',
          'Quels sont les b√©n√©fices ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'game_rules_shown' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };
    }

    if (message.includes('c\'est pour qui') || message.includes('C\'est pour qui')) {
      return {
        type: 'assistant',
        content: `üë• **${productName} est parfait pour :**

‚ù§Ô∏è **Les couples** qui veulent renforcer leur complicit√©
üë®‚Äçüë©‚Äçüëß‚Äçüë¶ **Les familles** qui souhaitent cr√©er des liens plus forts  
üë´ **Les amis** qui veulent approfondir leur amiti√©
üíº **Les coll√®gues** pour am√©liorer la coh√©sion d'√©quipe
üîÑ **Toute relation** qui m√©rite d'√™tre enrichie

‚ú® **Peu importe votre √¢ge ou votre situation**, nos jeux s'adaptent √† tous !

üéØ **L'important :** Avoir envie de cr√©er des moments authentiques ensemble.`,
        choices: [
          'Je veux l\'acheter maintenant',
          'Comment y jouer ?',
          'Quels sont les b√©n√©fices ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'target_audience_shown' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };
    }

    if (message.includes('b√©n√©fices') || message.includes('Quels sont les b√©n√©fices')) {
      return {
        type: 'assistant',
        content: `‚ú® **Les b√©n√©fices de ${productName} :**

üéØ **Communication am√©lior√©e**
‚Ä¢ Conversations plus profondes et authentiques
‚Ä¢ Meilleure √©coute mutuelle

‚ù§Ô∏è **Relation renforc√©e**  
‚Ä¢ Complicit√© accrue
‚Ä¢ Confiance mutuelle d√©velopp√©e

üîç **D√©couverte mutuelle**
‚Ä¢ Apprendre des choses nouvelles sur l'autre
‚Ä¢ Comprendre ses valeurs et ses r√™ves

üòå **Bien-√™tre relationnel**
‚Ä¢ Moins de malentendus
‚Ä¢ Plus de moments complices

üéÅ **Bonus :** Des souvenirs inoubliables √† chaque partie !`,
        choices: [
          'Je veux l\'acheter maintenant',
          'Comment y jouer ?',
          'C\'est pour qui ?'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'benefits_shown' as ConversationStep,
          productId: productId
        },
        timestamp: new Date().toISOString()
      };
    }

    // Question g√©n√©rale par d√©faut
    return {
      type: 'assistant',
      content: `ü§î **Bonne question !** 

Je suis l√† pour vous aider avec toutes vos interrogations sur le jeu **${productName}**.

Que souhaitez-vous savoir exactement ?`,
      choices: [
        'Comment y jouer ?',
        'C\'est pour qui ?',
        'Quels sont les b√©n√©fices ?'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'question_mode' as ConversationStep,
        productId: productId
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ GESTION DES QUESTIONS LIBRES - VERSION SIMPLIFI√âE
  private async handleFreeTextQuestion(
    message: string,
    productId: string,
    productName: string,
    sessionId: string
  ): Promise<ChatMessage> {
    
    // R√©ponse simplifi√©e sans appel API
    return {
      type: 'assistant',
      content: `Je comprends votre question sur **${productName}**.

Laissez-moi vous orienter vers les informations les plus utiles :`,
      choices: [
        'Comment y jouer ?',
        'C\'est pour qui ?',
        'Quels sont les b√©n√©fices ?',
        'Je veux l\'acheter maintenant'
      ],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'question_redirect' as ConversationStep,
        productId: productId,
        flags: { simplified: true }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ CR√âER MESSAGE D'UPSELL
  private async createUpsellMessage(currentProductId: string): Promise<ChatMessage> {
    try {
      // R√©cup√©rer d'autres jeux pour l'upsell
      const { data: relatedProducts } = await supabase
        .from('products')
        .select('id, name, price')
        .eq('status', 'active')
        .neq('id', currentProductId)
        .limit(3);

      if (!relatedProducts || relatedProducts.length === 0) {
        return {
          type: 'assistant',
          content: `üõçÔ∏è **Nos autres jeux seront bient√¥t disponibles !**

En attendant, t√©l√©chargez notre app mobile pour d√©couvrir tous nos jeux :`,
          choices: [
            'üì± T√©l√©charger l\'app',
            '‚úÖ Merci, c\'est tout'
          ],
          assistant: { name: 'Rose', title: 'Assistante d\'achat' },
          metadata: {
            nextStep: 'app_recommendation' as ConversationStep
          },
          timestamp: new Date().toISOString()
        };
      }

      return {
        type: 'assistant',
        content: `üõçÔ∏è **Nos autres jeux populaires :**

Profitez de 10% de r√©duction sur votre prochain achat !`,
        choices: [
          ...relatedProducts.map(p => `Ajouter ${p.name}`),
          'Non merci, √ßa suffit'
        ],
        assistant: { name: 'Rose', title: 'Assistante d\'achat' },
        metadata: {
          nextStep: 'upsell_selection' as ConversationStep,
          relatedProducts: relatedProducts
        },
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('‚ùå Error creating upsell message:', error);
      return this.createErrorMessage('Impossible de charger les autres jeux.');
    }
  }

  // ‚úÖ M√âTHODES UTILITAIRES
  private isWelcomeButtonChoice(message: string): boolean {
    const welcomeChoices = [
      'j\'ai des questions √† poser',
      'je veux en savoir plus',
      'questions √† poser',
      'en savoir plus',
      'poser une question'
    ];
    
    return welcomeChoices.some(choice => 
      message.toLowerCase().includes(choice.toLowerCase())
    );
  }

  private isPredefinedQuestion(message: string): boolean {
    const predefinedQuestions = [
      'comment y jouer',
      'c\'est pour qui',
      'quels sont les b√©n√©fices',
      't√©l√©charger l\'application',
      'livraison'
    ];
    
    return predefinedQuestions.some(question => 
      message.toLowerCase().includes(question.toLowerCase())
    );
  }

  private async getProductData(productId: string): Promise<{ price: number }> {
    try {
      const { data: product } = await supabase
        .from('products')
        .select('price')
        .eq('id', productId)
        .single();

      return { price: product?.price || 14000 };
    } catch (error) {
      console.error('‚ùå Error fetching product data:', error);
      return { price: 14000 }; // Prix par d√©faut
    }
  }

  private createErrorMessage(errorText: string): ChatMessage {
    return {
      type: 'assistant',
      content: `üòî **${errorText}**

Voulez-vous r√©essayer ou contacter notre support ?`,
      choices: ['üîÑ R√©essayer', 'üìû Contacter le support'],
      assistant: { name: 'Rose', title: 'Assistante d\'achat' },
      metadata: {
        nextStep: 'error_recovery' as ConversationStep,
        flags: { hasError: true }
      },
      timestamp: new Date().toISOString()
    };
  }
}