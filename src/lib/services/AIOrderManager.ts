// src/lib/services/AIOrderManager.ts

import { supabase } from '@/lib/supabase';
import type { 
  ChatMessage, 
  ConversationStep,
  CustomerData,
  OrderData,
  OrderStatus,
  PaymentProvider,
  PaymentStatus
} from '@/types/chat';

interface OrderSession {
  sessionId: string;
  currentStep: ConversationStep;
  orderData: Partial<OrderData>;
  customerData: Partial<CustomerData>;
  metadata: Record<string, any>;
  startedAt: string;
  lastUpdated: string;
}

interface OrderValidation {
  isValid: boolean;
  missingFields: string[];
  errors: string[];
}

export class AIOrderManager {
  private static instance: AIOrderManager;
  private orderSessions: Map<string, OrderSession> = new Map();

  private constructor() {}

  public static getInstance(): AIOrderManager {
    if (!this.instance) {
      this.instance = new AIOrderManager();
    }
    return this.instance;
  }

  /**
   * üöÄ M√âTHODE: D√©marrer une nouvelle commande
   */
  async startOrder(
    sessionId: string,
    productId: string,
    flow: 'express' | 'guided' = 'guided'
  ): Promise<ChatMessage> {
    try {
      console.log('üõí D√©marrage commande:', { sessionId, productId, flow });

      // R√©cup√©rer les infos du produit
      const { data: product, error } = await supabase
        .from('products')
        .select('*')
        .eq('id', productId)
        .eq('status', 'active')
        .single();

      if (error || !product) {
        return this.createErrorResponse('Produit non trouv√© ou indisponible');
      }

      // Cr√©er la session de commande
      const orderSession: OrderSession = {
        sessionId,
        currentStep: flow === 'express' ? 'express_quantity' : 'collect_quantity',
        orderData: {
          product_id: productId,
          product_name: product.name,
          unit_price: product.price,
          quantity: 1,
          status: 'pending' as OrderStatus
        },
        customerData: {},
        metadata: {
          flow,
          productInfo: product,
          startedAt: new Date().toISOString()
        },
        startedAt: new Date().toISOString(),
        lastUpdated: new Date().toISOString()
      };

      this.orderSessions.set(sessionId, orderSession);

      // Retourner le premier message selon le flux
      if (flow === 'express') {
        return this.handleExpressQuantity(sessionId);
      } else {
        return this.handleGuidedQuantity(sessionId);
      }

    } catch (error) {
      console.error('‚ùå Erreur d√©marrage commande:', error);
      return this.createErrorResponse('Erreur lors du d√©marrage de la commande');
    }
  }

  /**
   * ‚ö° M√âTHODE: G√©rer la quantit√© en mode express
   */
  private async handleExpressQuantity(sessionId: string): Promise<ChatMessage> {
    const session = this.orderSessions.get(sessionId);
    if (!session) return this.createErrorResponse('Session non trouv√©e');

    const product = session.metadata.productInfo;

    return {
      type: 'assistant',
      content: `‚ö° **Commande Express - ${product.name}**

üí∞ **Prix unitaire:** ${product.price.toLocaleString()} FCFA

Combien de jeux souhaitez-vous commander ?

‚≠ê **Plus vous en prenez, plus vous √©conomisez sur la livraison !**`,
      choices: ['1 jeu', '2 jeux', '3 jeux', 'Autre quantit√©'],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'express_quantity' as ConversationStep,
        sessionId,
        flow: 'express'
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üß≠ M√âTHODE: G√©rer la quantit√© en mode guid√©
   */
  private async handleGuidedQuantity(sessionId: string): Promise<ChatMessage> {
    const session = this.orderSessions.get(sessionId);
    if (!session) return this.createErrorResponse('Session non trouv√©e');

    const product = session.metadata.productInfo;

    return {
      type: 'assistant',
      content: `üõí **Pr√©paration de votre commande**

**${product.name}**
${product.description || 'Un jeu pour renforcer vos relations'}

üí∞ **Prix:** ${product.price.toLocaleString()} FCFA

Combien d'exemplaires voulez-vous ?

üí° **Conseil:** Beaucoup de familles prennent 2 jeux pour en offrir un ou avoir des parties avec plus de personnes !`,
      choices: ['1 jeu', '2 jeux', '3 jeux', 'Je veux en savoir plus'],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'collect_quantity' as ConversationStep,
        sessionId,
        flow: 'guided'
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üìù M√âTHODE: Traiter la r√©ponse de quantit√©
   */
  async processQuantityResponse(
    sessionId: string,
    response: string
  ): Promise<ChatMessage> {
    try {
      const session = this.orderSessions.get(sessionId);
      if (!session) return this.createErrorResponse('Session non trouv√©e');

      let quantity = 1;
      
      // Parser la r√©ponse
      if (response.includes('1')) quantity = 1;
      else if (response.includes('2')) quantity = 2;
      else if (response.includes('3')) quantity = 3;
      else if (response.toLowerCase().includes('autre')) {
        return this.askCustomQuantity(sessionId);
      }

      // Mettre √† jour la session
      session.orderData.quantity = quantity;
      session.orderData.subtotal = (session.orderData.unit_price || 0) * quantity;
      session.lastUpdated = new Date().toISOString();

      // Passer √† l'√©tape suivante selon le flux
      if (session.metadata.flow === 'express') {
        session.currentStep = 'express_contact';
        return this.handleExpressContact(sessionId);
      } else {
        session.currentStep = 'collect_name';
        return this.handleCollectName(sessionId);
      }

    } catch (error) {
      console.error('‚ùå Erreur traitement quantit√©:', error);
      return this.createErrorResponse('Erreur lors du traitement de la quantit√©');
    }
  }

  /**
   * üî¢ M√âTHODE: Demander une quantit√© personnalis√©e
   */
  private askCustomQuantity(sessionId: string): ChatMessage {
    return {
      type: 'assistant',
      content: `üî¢ **Quantit√© personnalis√©e**

Parfait ! Combien de jeux souhaitez-vous exactement ?

Tapez simplement le nombre (exemple: 4, 5, 10...)`,
      choices: ['4 jeux', '5 jeux', '10 jeux', 'Plus de 10'],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'custom_quantity' as ConversationStep,
        sessionId,
        expectingNumber: true
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * ‚ö° M√âTHODE: Collecter les infos de contact en mode express
   */
  private async handleExpressContact(sessionId: string): Promise<ChatMessage> {
    const session = this.orderSessions.get(sessionId);
    if (!session) return this.createErrorResponse('Session non trouv√©e');

    const { quantity, subtotal } = session.orderData;

    return {
      type: 'assistant',
      content: `üìû **Vos coordonn√©es - √âtape 2/4**

**R√©capitulatif:**
‚Ä¢ ${quantity} x ${session.metadata.productInfo.name}
‚Ä¢ Total: ${subtotal?.toLocaleString()} FCFA

Pour traiter votre commande rapidement, j'ai besoin de:

üì± **Votre num√©ro de t√©l√©phone**
(pour confirmer la commande et la livraison)

Tapez votre num√©ro complet:`,
      choices: [],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'express_contact' as ConversationStep,
        sessionId,
        expectingPhone: true
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üë§ M√âTHODE: Collecter le nom en mode guid√©
   */
  private async handleCollectName(sessionId: string): Promise<ChatMessage> {
    const session = this.orderSessions.get(sessionId);
    if (!session) return this.createErrorResponse('Session non trouv√©e');

    return {
      type: 'assistant',
      content: `üë§ **Vos informations personnelles**

Parfait ! ${session.orderData.quantity} jeu(x) s√©lectionn√©(s).

Pour commencer, quel est votre nom complet ?

üí° **Exemple:** Jean-Baptiste Diallo`,
      choices: [],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'collect_name' as ConversationStep,
        sessionId,
        expectingName: true
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üì± M√âTHODE: Traiter le num√©ro de t√©l√©phone
   */
  async processPhoneNumber(
    sessionId: string,
    phone: string
  ): Promise<ChatMessage> {
    try {
      const session = this.orderSessions.get(sessionId);
      if (!session) return this.createErrorResponse('Session non trouv√©e');

      // Validation du num√©ro
      const cleanPhone = this.cleanPhoneNumber(phone);
      if (!this.isValidPhone(cleanPhone)) {
        return {
          type: 'assistant',
          content: `‚ùå **Num√©ro invalide**

Le num√©ro "${phone}" ne semble pas valide.

üì± **Formats accept√©s:**
‚Ä¢ +221 77 123 45 67
‚Ä¢ 77 123 45 67
‚Ä¢ 221771234567

Veuillez retaper votre num√©ro:`,
          choices: [],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: {
            nextStep: session.currentStep,
            sessionId,
            expectingPhone: true,
            error: 'invalid_phone'
          },
          timestamp: new Date().toISOString()
        };
      }

      // V√©rifier si le client existe
      const existingCustomer = await this.findExistingCustomer(cleanPhone);
      
      session.customerData.phone = cleanPhone;
      session.lastUpdated = new Date().toISOString();

      if (existingCustomer) {
        // Client existant
        session.customerData = { ...session.customerData, ...existingCustomer };
        session.metadata.existingCustomer = true;

        return {
          type: 'assistant',
          content: `üëã **Bon retour ${existingCustomer.first_name} !**

Je vois que vous avez d√©j√† command√© chez nous. 

üìç **Derni√®re adresse connue:**
${existingCustomer.address}, ${existingCustomer.city}

Souhaitez-vous livrer √† la m√™me adresse ?`,
          choices: [
            '‚úÖ Oui, m√™me adresse',
            'üìç Non, nouvelle adresse',
            'üìã Voir mes commandes pr√©c√©dentes'
          ],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: {
            nextStep: 'confirm_address' as ConversationStep,
            sessionId,
            existingCustomer: true
          },
          timestamp: new Date().toISOString()
        };
      } else {
        // Nouveau client
        session.metadata.newCustomer = true;

        if (session.metadata.flow === 'express') {
          return this.handleExpressNewCustomer(sessionId);
        } else {
          return this.handleNewCustomerName(sessionId);
        }
      }

    } catch (error) {
      console.error('‚ùå Erreur traitement t√©l√©phone:', error);
      return this.createErrorResponse('Erreur lors du traitement du num√©ro');
    }
  }

  /**
   * ‚ö° M√âTHODE: Nouveau client en mode express
   */
  private handleExpressNewCustomer(sessionId: string): ChatMessage {
    return {
      type: 'assistant',
      content: `üÜï **Nouveau client - Bienvenue !**

Enchant√© de vous rencontrer ! 

Pour finaliser rapidement votre commande:

üë§ **Votre nom complet:**
(pr√©nom et nom de famille)`,
      choices: [],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'express_name' as ConversationStep,
        sessionId,
        expectingName: true
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üë§ M√âTHODE: Nom pour nouveau client mode guid√©
   */
  private handleNewCustomerName(sessionId: string): ChatMessage {
    return {
      type: 'assistant',
      content: `üÜï **Nouveau client - Bienvenue chez VIENS ON S'CONNA√éT !**

C'est formidable d'avoir un nouveau membre dans notre communaut√© ! 

üë§ **Pour commencer, quel est votre nom complet ?**

üí° **Exemple:** Aminata Ba`,
      choices: [],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'collect_name' as ConversationStep,
        sessionId,
        expectingName: true,
        newCustomer: true
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üë§ M√âTHODE: Traiter le nom du client
   */
  async processCustomerName(
    sessionId: string,
    fullName: string
  ): Promise<ChatMessage> {
    try {
      const session = this.orderSessions.get(sessionId);
      if (!session) return this.createErrorResponse('Session non trouv√©e');

      // Parser le nom
      const { firstName, lastName } = this.parseFullName(fullName);
      
      if (!firstName) {
        return {
          type: 'assistant',
          content: `‚ùå **Nom incomplet**

Pourriez-vous me donner votre nom complet ?

üë§ **Exemple:** Fatou Sall ou Jean-Pierre Diagne

Votre nom complet:`,
          choices: [],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: {
            nextStep: session.currentStep,
            sessionId,
            expectingName: true,
            error: 'incomplete_name'
          },
          timestamp: new Date().toISOString()
        };
      }

      // Mettre √† jour les donn√©es client
      session.customerData.first_name = firstName;
      session.customerData.last_name = lastName || '';
      session.lastUpdated = new Date().toISOString();

      // Passer √† l'√©tape suivante selon le flux
      if (session.metadata.flow === 'express') {
        session.currentStep = 'express_address';
        return this.handleExpressAddress(sessionId);
      } else {
        session.currentStep = 'collect_phone';
        return this.handleCollectPhone(sessionId);
      }

    } catch (error) {
      console.error('‚ùå Erreur traitement nom:', error);
      return this.createErrorResponse('Erreur lors du traitement du nom');
    }
  }

  /**
   * üì± M√âTHODE: Collecter le t√©l√©phone en mode guid√©
   */
  private handleCollectPhone(sessionId: string): ChatMessage {
    const session = this.orderSessions.get(sessionId);
    if (!session) return this.createErrorResponse('Session non trouv√©e');

    return {
      type: 'assistant',
      content: `üì± **Votre num√©ro de t√©l√©phone**

Merci ${session.customerData.first_name} !

J'ai besoin de votre num√©ro de t√©l√©phone pour:
‚Ä¢ üìû Confirmer votre commande
‚Ä¢ üöö Coordonner la livraison
‚Ä¢ üìß Vous envoyer le suivi

**Votre num√©ro:**`,
      choices: [],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'collect_phone' as ConversationStep,
        sessionId,
        expectingPhone: true
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * ‚ö° M√âTHODE: Adresse en mode express
   */
  private handleExpressAddress(sessionId: string): ChatMessage {
    const session = this.orderSessions.get(sessionId);
    if (!session) return this.createErrorResponse('Session non trouv√©e');

    return {
      type: 'assistant',
      content: `üìç **Adresse de livraison - √âtape 3/4**

Parfait ${session.customerData.first_name} !

**Votre adresse compl√®te de livraison:**

üìù **Format:** Rue/Quartier, Ville, Pays
üí° **Exemple:** Rond-point Fann, Dakar, S√©n√©gal

Votre adresse:`,
      choices: [],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'express_address' as ConversationStep,
        sessionId,
        expectingAddress: true
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üìç M√âTHODE: Traiter l'adresse
   */
  async processAddress(
    sessionId: string,
    address: string
  ): Promise<ChatMessage> {
    try {
      const session = this.orderSessions.get(sessionId);
      if (!session) return this.createErrorResponse('Session non trouv√©e');

      // Parser l'adresse
      const { street, city, country } = this.parseAddress(address);
      
      if (!street || !city) {
        return {
          type: 'assistant',
          content: `‚ùå **Adresse incompl√®te**

L'adresse "${address}" semble incompl√®te.

üìç **J'ai besoin de:**
‚Ä¢ Rue ou quartier
‚Ä¢ Ville
‚Ä¢ Pays (optionnel)

üí° **Exemple:** Plateau, Dakar, S√©n√©gal

Votre adresse compl√®te:`,
          choices: [],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: {
            nextStep: session.currentStep,
            sessionId,
            expectingAddress: true,
            error: 'incomplete_address'
          },
          timestamp: new Date().toISOString()
        };
      }

      // V√©rifier la zone de livraison
      const deliveryInfo = await this.checkDeliveryZone(city);
      
      if (!deliveryInfo.available) {
        return {
          type: 'assistant',
          content: `üòî **Livraison non disponible**

D√©sol√©e, nous ne livrons pas encore √† ${city}.

üöö **Zones disponibles:**
${deliveryInfo.availableZones.slice(0, 8).join(' ‚Ä¢ ')}

üìû **Solution:** Contactez-nous sur WhatsApp pour une livraison sp√©ciale:
+221 78 136 27 28`,
          choices: [
            'üìû Contacter WhatsApp',
            'üìç Changer d\'adresse',
            'üè† Retour accueil'
          ],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: {
            nextStep: 'delivery_unavailable' as ConversationStep,
            sessionId,
            whatsappUrl: 'https://wa.me/221781362728'
          },
          timestamp: new Date().toISOString()
        };
      }

      // Mettre √† jour les donn√©es
      session.customerData.address = street;
      session.customerData.city = city;
      session.customerData.country = country || 'S√©n√©gal';
      session.orderData.delivery_city = city;
      session.orderData.delivery_address = address;
      session.orderData.delivery_fee = deliveryInfo.fee;
      session.orderData.total_amount = (session.orderData.subtotal || 0) + deliveryInfo.fee;
      session.lastUpdated = new Date().toISOString();

      // Passer √† l'√©tape suivante
      if (session.metadata.flow === 'express') {
        session.currentStep = 'express_payment';
        return this.handleExpressPayment(sessionId);
      } else {
        session.currentStep = 'order_summary';
        return this.handleOrderSummary(sessionId);
      }

    } catch (error) {
      console.error('‚ùå Erreur traitement adresse:', error);
      return this.createErrorResponse('Erreur lors du traitement de l\'adresse');
    }
  }

  /**
   * ‚ö° M√âTHODE: Paiement en mode express
   */
  private async handleExpressPayment(sessionId: string): Promise<ChatMessage> {
    const session = this.orderSessions.get(sessionId);
    if (!session) return this.createErrorResponse('Session non trouv√©e');

    const { subtotal, delivery_fee, total_amount } = session.orderData;

    return {
      type: 'assistant',
      content: `üí≥ **Paiement - Derni√®re √©tape !**

**R√©capitulatif final:**
‚Ä¢ ${session.orderData.quantity}x ${session.metadata.productInfo.name}
‚Ä¢ Sous-total: ${subtotal?.toLocaleString()} FCFA
‚Ä¢ Livraison: ${delivery_fee === 0 ? 'GRATUITE ‚ú®' : `${delivery_fee?.toLocaleString()} FCFA`}
‚Ä¢ **Total: ${total_amount?.toLocaleString()} FCFA**

üìç **Livraison:** ${session.customerData.address}, ${session.customerData.city}

Choisissez votre mode de paiement:`,
      choices: [
        'üì± Wave (Recommand√©)',
        'üí≥ Carte bancaire',
        'üí∞ Paiement √† la livraison',
        'üìû Autre m√©thode'
      ],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'express_payment' as ConversationStep,
        sessionId,
        orderSummary: session.orderData
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üìã M√âTHODE: R√©sum√© de commande mode guid√©
   */
  private handleOrderSummary(sessionId: string): ChatMessage {
    const session = this.orderSessions.get(sessionId);
    if (!session) return this.createErrorResponse('Session non trouv√©e');

    const { quantity, unit_price, subtotal, delivery_fee, total_amount } = session.orderData;
    const { first_name, address, city } = session.customerData;

    return {
      type: 'assistant',
      content: `üìã **R√©capitulatif de votre commande**

üë§ **Client:** ${first_name}
üì¶ **Produit:** ${quantity}x ${session.metadata.productInfo.name}
üí∞ **Prix unitaire:** ${unit_price?.toLocaleString()} FCFA
üìç **Livraison:** ${address}, ${city}

**üí∏ D√©tail des co√ªts:**
‚Ä¢ Sous-total: ${subtotal?.toLocaleString()} FCFA
‚Ä¢ Livraison: ${delivery_fee === 0 ? 'GRATUITE ‚ú®' : `${delivery_fee?.toLocaleString()} FCFA`}
‚Ä¢ **Total final: ${total_amount?.toLocaleString()} FCFA**

Tout est correct ?`,
      choices: [
        '‚úÖ Parfait, continuer',
        '‚úèÔ∏è Modifier quelque chose',
        '‚ùì J\'ai une question'
      ],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'order_summary' as ConversationStep,
        sessionId,
        orderData: session.orderData
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üí≥ M√âTHODE: Traiter le choix de paiement
   */
  async processPaymentChoice(
    sessionId: string,
    paymentMethod: string
  ): Promise<ChatMessage> {
    try {
      const session = this.orderSessions.get(sessionId);
      if (!session) return this.createErrorResponse('Session non trouv√©e');

      // D√©terminer le type de paiement
      let paymentType: PaymentProvider = 'other';
        if (paymentMethod.toLowerCase().includes('wave')) paymentType = 'wave';
        else if (paymentMethod.toLowerCase().includes('carte')) paymentType = 'card';
        else if (paymentMethod.toLowerCase().includes('livraison')) paymentType = 'cash_on_delivery';
        else if (paymentMethod.toLowerCase().includes('orange')) paymentType = 'orange_money';

      session.orderData.payment_method = paymentType as PaymentProvider;
      session.lastUpdated = new Date().toISOString();

      // Cr√©er la commande en base
      const orderId = await this.createOrderInDatabase(session);
      
      if (!orderId) {
        return this.createErrorResponse('Erreur lors de la cr√©ation de la commande');
      }

      session.orderData.id = orderId;
      session.currentStep = 'order_confirmed';

      // G√©n√©rer le message de confirmation selon le type de paiement
      return this.generatePaymentInstructions(sessionId, paymentType, orderId);

    } catch (error) {
      console.error('‚ùå Erreur traitement paiement:', error);
      return this.createErrorResponse('Erreur lors du traitement du paiement');
    }
  }

  /**
   * üí≥ M√âTHODE: G√©n√©rer les instructions de paiement
   */
  private generatePaymentInstructions(
    sessionId: string,
    paymentType: string,
    orderId: string
  ): ChatMessage {
    const session = this.orderSessions.get(sessionId);
    if (!session) return this.createErrorResponse('Session non trouv√©e');

    const { total_amount } = session.orderData;

    switch (paymentType) {
      case 'wave':
        return {
          type: 'assistant',
          content: `üì± **Paiement Wave - Commande #${orderId.substring(0, 8)}**

‚úÖ **Votre commande est enregistr√©e !**

üí≥ **Instructions Wave:**
1Ô∏è‚É£ Ouvrez votre app Wave
2Ô∏è‚É£ Envoyez ${total_amount?.toLocaleString()} FCFA au:
üìû **+221 78 136 27 28**
üí¨ **R√©f√©rence:** ${orderId.substring(0, 8)}

‚è∞ **Important:** Nous recevons la confirmation instantan√©ment

Une fois le paiement effectu√©, votre commande sera pr√©par√©e !`,
          choices: [
            '‚úÖ J\'ai pay√©',
            '‚ùì Probl√®me de paiement',
            'üìû Contacter le support'
          ],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: {
            nextStep: 'payment_confirmation' as ConversationStep,
            sessionId,
            orderId,
            paymentMethod: 'wave'
          },
          timestamp: new Date().toISOString()
        };

      case 'card':
        return {
          type: 'assistant',
          content: `üí≥ **Paiement par carte - Commande #${orderId.substring(0, 8)}**

‚úÖ **Votre commande est enregistr√©e !**

Vous allez √™tre redirig√©(e) vers notre page de paiement s√©curis√©e.

üí∞ **Montant:** ${total_amount?.toLocaleString()} FCFA
üîí **S√©curis√© par Stripe**
üí≥ **Cartes accept√©es:** Visa, MasterCard

Cliquez pour payer maintenant:`,
          choices: [
            'üí≥ Payer par carte',
            'üì± Changer pour Wave',
            'üìû Aide au paiement'
          ],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: {
            nextStep: 'card_payment' as ConversationStep,
            sessionId,
            orderId,
            paymentUrl: `/payment/${orderId}`,
            paymentMethod: 'card'
          },
          timestamp: new Date().toISOString()
        };

      case 'cash_on_delivery':
        return {
          type: 'assistant',
          content: `üí∞ **Paiement √† la livraison - Commande #${orderId.substring(0, 8)}**

‚úÖ **Votre commande est confirm√©e !**

üì¶ **Ce qui va se passer:**
1Ô∏è‚É£ Nous pr√©parons votre commande (24-48h)
2Ô∏è‚É£ Notre livreur vous contacte
3Ô∏è‚É£ Vous payez ${total_amount?.toLocaleString()} FCFA √† la r√©ception

üí° **Pr√©parez l'appoint si possible**

üì± **Suivi:** Vous recevrez des SMS avec le statut de livraison

Votre commande est maintenant en pr√©paration !`,
          choices: [
            'üì¶ Suivre ma commande',
            'üì± SMS de confirmation',
            'üìû Nous contacter'
          ],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: {
            nextStep: 'order_confirmed' as ConversationStep,
            sessionId,
            orderId,
            paymentMethod: 'cash_on_delivery'
          },
          timestamp: new Date().toISOString()
        };

      default:
        return {
          type: 'assistant',
          content: `üìû **Paiement personnalis√© - Commande #${orderId.substring(0, 8)}**

‚úÖ **Votre commande est enregistr√©e !**

Notre √©quipe va vous contacter dans les 30 minutes pour finaliser le paiement.

üì± **Contact:** +221 78 136 27 28
üí∞ **Montant:** ${total_amount?.toLocaleString()} FCFA

En attendant, nous pr√©parons d√©j√† votre commande !`,
          choices: [
            'üìû Nous appeler maintenant',
            'üì± WhatsApp direct',
            '‚è∞ Attendre l\'appel'
          ],
          assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
          metadata: {
            nextStep: 'custom_payment' as ConversationStep,
            sessionId,
            orderId,
            whatsappUrl: `https://wa.me/221781362728?text=Commande%20${orderId.substring(0, 8)}`
          },
          timestamp: new Date().toISOString()
        };
    }
  }

  /**
   * üíæ M√âTHODE: Cr√©er la commande en base de donn√©es
   */
  private async createOrderInDatabase(session: OrderSession): Promise<string | null> {
    try {
      // Pr√©parer les donn√©es de la commande
      const orderData = {
        customer_phone: session.customerData.phone,
        customer_name: `${session.customerData.first_name} ${session.customerData.last_name}`.trim(),
        product_id: session.orderData.product_id,
        product_name: session.orderData.product_name,
        quantity: session.orderData.quantity,
        unit_price: session.orderData.unit_price,
        subtotal: session.orderData.subtotal,
        delivery_fee: session.orderData.delivery_fee,
        total_amount: session.orderData.total_amount,
        delivery_address: session.orderData.delivery_address,
        delivery_city: session.orderData.delivery_city,
        payment_method: session.orderData.payment_method,
        status: 'pending',
        payment_status: 'pending',
        metadata: {
          source: 'ai_chat',
          sessionId: session.sessionId,
          flow: session.metadata.flow,
          createdAt: new Date().toISOString()
        },
        order_details: JSON.stringify([{
          productId: session.orderData.product_id,
          name: session.orderData.product_name,
          quantity: session.orderData.quantity,
          price: session.orderData.unit_price,
          totalPrice: session.orderData.subtotal
        }])
      };

      // Ins√©rer la commande
      const { data: order, error } = await supabase
        .from('orders')
        .insert(orderData)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Erreur cr√©ation commande:', error);
        return null;
      }

      // Sauvegarder ou mettre √† jour le client
      await this.saveCustomerData(session.customerData);

      return order.id;

    } catch (error) {
      console.error('‚ùå Erreur cr√©ation commande:', error);
      return null;
    }
  }

  /**
   * üë§ M√âTHODE: Sauvegarder les donn√©es client
   */
  private async saveCustomerData(customerData: Partial<CustomerData>): Promise<void> {
    try {
      if (!customerData.phone) return;

      const { data: existingCustomer } = await supabase
        .from('customers')
        .select('id')
        .eq('phone', customerData.phone)
        .single();

      if (existingCustomer) {
        // Mettre √† jour client existant
        await supabase
          .from('customers')
          .update({
            first_name: customerData.first_name,
            last_name: customerData.last_name,
            address: customerData.address,
            city: customerData.city,
            country: customerData.country,
            updated_at: new Date().toISOString()
          })
          .eq('phone', customerData.phone);
      } else {
        // Cr√©er nouveau client
        await supabase
          .from('customers')
          .insert({
            ...customerData,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          });
      }

    } catch (error) {
      console.error('‚ùå Erreur sauvegarde client:', error);
    }
  }

  // ==========================================
  // M√âTHODES UTILITAIRES
  // ==========================================

  private cleanPhoneNumber(phone: string): string {
    return phone.replace(/\D/g, '');
  }

  private isValidPhone(phone: string): boolean {
    // Validation pour les num√©ros s√©n√©galais et africains
    return /^(221)?\d{9}$/.test(phone) || /^\d{8,15}$/.test(phone);
  }

  private parseFullName(fullName: string): { firstName: string; lastName?: string } {
    const parts = fullName.trim().split(/\s+/);
    return {
      firstName: parts[0] || '',
      lastName: parts.slice(1).join(' ') || undefined
    };
  }

  private parseAddress(address: string): { street: string; city: string; country?: string } {
    const parts = address.split(',').map(part => part.trim());
    
    return {
      street: parts[0] || '',
      city: parts[1] || '',
      country: parts[2] || undefined
    };
  }

  private async findExistingCustomer(phone: string): Promise<CustomerData | null> {
    try {
      const { data: customer, error } = await supabase
        .from('customers')
        .select('*')
        .eq('phone', phone)
        .single();

      return error ? null : customer;
    } catch (error) {
      return null;
    }
  }

  private async checkDeliveryZone(city: string): Promise<{
    available: boolean;
    fee: number;
    availableZones: string[];
  }> {
    try {
      const { data: zones, error } = await supabase
        .from('delivery_zones')
        .select('*');

      if (error || !zones) {
        return { available: false, fee: 0, availableZones: [] };
      }

      const availableZones = zones.flatMap(zone => zone.cities || []);
      
      const matchingZone = zones.find(zone => 
        zone.cities?.some((zoneCity: string) => 
          city.toLowerCase().includes(zoneCity.toLowerCase()) ||
          zoneCity.toLowerCase().includes(city.toLowerCase())
        )
      );

      return {
        available: !!matchingZone,
        fee: matchingZone?.base_price || 0,
        availableZones
      };

    } catch (error) {
      console.error('‚ùå Erreur v√©rification zone:', error);
      return { available: false, fee: 0, availableZones: [] };
    }
  }

  private createErrorResponse(message: string): ChatMessage {
    return {
      type: 'assistant',
      content: `‚ùå **Erreur**

${message}

üìû **Besoin d'aide ?**
WhatsApp : +221 78 136 27 28`,
      choices: ['üîÑ R√©essayer', 'üìû WhatsApp', 'üè† Retour accueil'],
      assistant: { name: 'Rose', title: 'Conseill√®re VIENS ON S\'CONNA√éT' },
      metadata: {
        nextStep: 'error_recovery' as ConversationStep,
        error: 'true'
      },
      timestamp: new Date().toISOString()
    };
  }

  /**
   * üìä M√âTHODE: Obtenir les statistiques des commandes
   */
  async getOrderStats(): Promise<{
    activeOrders: number;
    completedToday: number;
    averageOrderValue: number;
    conversionRate: number;
  }> {
    try {
      const activeSessions = this.orderSessions.size;
      
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      const { data: todayOrders } = await supabase
        .from('orders')
        .select('total_amount')
        .gte('created_at', today.toISOString())
        .eq('status', 'confirmed');

      const { data: allOrders } = await supabase
        .from('orders')
        .select('total_amount')
        .eq('status', 'confirmed')
        .gte('created_at', new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString());

      const completedToday = todayOrders?.length || 0;
      const averageOrderValue = allOrders && allOrders.length > 0 ? 
        allOrders.reduce((sum, order) => sum + (order.total_amount || 0), 0) / allOrders.length : 0;

      return {
        activeOrders: activeSessions,
        completedToday,
        averageOrderValue: Math.round(averageOrderValue),
        conversionRate: 15.5 // Exemple - √† calculer selon vos m√©triques
      };

    } catch (error) {
      console.error('‚ùå Erreur statistiques commandes:', error);
      return {
        activeOrders: 0,
        completedToday: 0,
        averageOrderValue: 0,
        conversionRate: 0
      };
    }
  }

  /**
   * üßπ M√âTHODE: Nettoyer les sessions expir√©es
   */
  cleanupExpiredSessions(): void {
    const now = new Date();
    const expirationTime = 2 * 60 * 60 * 1000; // 2 heures

    for (const [sessionId, session] of this.orderSessions.entries()) {
      const sessionAge = now.getTime() - new Date(session.startedAt).getTime();
      
      if (sessionAge > expirationTime) {
        this.orderSessions.delete(sessionId);
        console.log(`üßπ Session commande expir√©e nettoy√©e: ${sessionId}`);
      }
    }
  }
}