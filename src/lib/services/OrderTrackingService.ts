// src/lib/services/OrderTrackingService.ts - VERSION COMPL√àTE CORRIG√âE
import { supabase } from '@/lib/supabase';
import type { ChatMessage, ConversationStep } from '@/types/chat';

// ‚úÖ CORRECTION 1: Types align√©s avec ChatOrderData
type OrderStatusType = 'pending' | 'confirmed' | 'cancelled';
type PaymentStatusType = 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled' | 'success';

interface OrderStatus {
  id: string;
  session_id?: string;
  status: OrderStatusType;
  payment_status: PaymentStatusType;
  created_at: string;
  updated_at: string;
  total_amount: number;
  customer_name: string;
  first_name: string;
  last_name: string;
  address: string;
  city: string;
  phone: string;
  order_details: any;
  tracking_number?: string;
  delivery_company?: string;
  payment_method?: string;
}

interface TrackingResponse {
  found: boolean;
  order?: OrderStatus;
  message: string;
  statusHistory?: Array<{
    status: string;
    date: string;
    description: string;
  }>;
}

// ‚úÖ CORRECTION 2: Fonction de validation du statut
function validateOrderStatus(status: any): OrderStatusType {
  const validStatuses: OrderStatusType[] = ['pending', 'confirmed', 'cancelled'];
  
  if (typeof status === 'string' && validStatuses.includes(status as OrderStatusType)) {
    return status as OrderStatusType;
  }
  
  // Mapping pour les statuts √©tendus vers les statuts de base
  const statusMapping: Record<string, OrderStatusType> = {
    'processing': 'confirmed',
    'shipped': 'confirmed', 
    'delivered': 'confirmed',
    'paid': 'confirmed',
    'failed': 'cancelled'
  };
  
  if (typeof status === 'string' && statusMapping[status]) {
    return statusMapping[status];
  }
  
  return 'pending'; // Valeur par d√©faut
}

// ‚úÖ CORRECTION 3: Fonction de validation ConversationStep
function validateConversationStep(step: any): ConversationStep {
  const validSteps: ConversationStep[] = [
    'initial', 'initial_engagement', 'mode_selection', 'generic_response',
    'error_recovery', 'fallback_response', 'whatsapp_redirect',
    'customer_support', 'order_details_shown', 
    'post_purchase_options', 'order_complete',
    // ‚úÖ CORRECTION: Utiliser des steps valides au lieu des steps manquants
    'customer_service',  // Au lieu de 'order_not_found'
    'error_recovery'     // Au lieu de 'tracking_error'
  ];

  if (typeof step === 'string' && validSteps.includes(step as ConversationStep)) {
    return step as ConversationStep;
  }
  
  return 'generic_response';
}

export class OrderTrackingService {
  private static instance: OrderTrackingService;

  private constructor() {}

  public static getInstance(): OrderTrackingService {
    if (!this.instance) {
      this.instance = new OrderTrackingService();
    }
    return this.instance;
  }

  // ‚úÖ M√âTHODE PRINCIPALE CORRIG√âE: R√©cup√©rer le statut de commande
  async getOrderStatus(sessionId: string): Promise<TrackingResponse> {
    try {
      console.log('üîç [TRACKING] Searching order for session:', sessionId);

      let order: any = null;
      let error: any = null;

      // Essayer d'abord par session_id
      const { data: orderBySession, error: sessionError } = await supabase
        .from('orders')
        .select('*')
        .eq('session_id', sessionId)
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      if (!sessionError && orderBySession) {
        order = orderBySession;
        console.log('‚úÖ [TRACKING] Order found by session_id:', order.id);
      } else {
        console.log('‚ö†Ô∏è [TRACKING] No order found by session_id, trying by ID...');
        
        // Essayer par ID si le sessionId ressemble √† un ID de commande
        if (sessionId.length < 20 && /^\d+$/.test(sessionId)) {
          const { data: orderById, error: idError } = await supabase
            .from('orders')
            .select('*')
            .eq('id', parseInt(sessionId))
            .single();

          if (!idError && orderById) {
            order = orderById;
            console.log('‚úÖ [TRACKING] Order found by ID:', order.id);
          } else {
            error = idError;
          }
        } else {
          error = sessionError;
        }
      }

      if (error || !order) {
        console.log('‚ùå [TRACKING] No order found for session:', sessionId, error);
        return {
          found: false,
          message: 'Aucune commande trouv√©e pour cette session.'
        };
      }

      console.log('‚úÖ [TRACKING] Order found:', order.id, 'Status:', order.status);

      // R√©cup√©rer l'historique des statuts si disponible
      const statusHistory = await this.getStatusHistory(order.id);

      return {
        found: true,
        order: order as OrderStatus,
        message: 'Commande trouv√©e avec succ√®s',
        statusHistory
      };

    } catch (error) {
      console.error('‚ùå [TRACKING] Error tracking order:', error);
      return {
        found: false,
        message: 'Erreur lors de la r√©cup√©ration du statut de commande.'
      };
    }
  }

  // ‚úÖ R√âCUP√âRER L'HISTORIQUE DES STATUTS
  private async getStatusHistory(orderId: string): Promise<Array<{
    status: string;
    date: string;
    description: string;
  }>> {
    try {
      const { data: history, error } = await supabase
        .from('delivery_status_history')
        .select('*')
        .eq('order_id', orderId)
        .order('created_at', { ascending: true });

      if (error || !history) {
        console.log('‚ö†Ô∏è [TRACKING] No status history found for order:', orderId);
        return [];
      }

      console.log('‚úÖ [TRACKING] Status history found:', history.length, 'entries');

      return history.map(entry => ({
        status: entry.status,
        date: entry.created_at,
        description: entry.notes || this.getStatusDescription(validateOrderStatus(entry.status))
      }));

    } catch (error) {
      console.error('‚ùå [TRACKING] Error fetching status history:', error);
      return [];
    }
  }

  // ‚úÖ DESCRIPTIONS DES STATUTS CORRIG√âES
  private getStatusDescription(status: OrderStatusType): string {
    const descriptions: Record<OrderStatusType, string> = {
      'pending': 'Commande re√ßue et en attente de traitement',
      'confirmed': 'Commande confirm√©e et valid√©e',
      'cancelled': 'Commande annul√©e'
    };

    return descriptions[status] || 'Statut mis √† jour';
  }

  // ‚úÖ CR√âER UN MESSAGE DE CHAT AVEC LE STATUT D√âTAILL√â
  async createTrackingMessage(sessionId: string): Promise<ChatMessage> {
    console.log('üîç [TRACKING] Creating tracking message for session:', sessionId);
    
    const trackingResponse = await this.getOrderStatus(sessionId);

    if (!trackingResponse.found) {
      console.log('‚ùå [TRACKING] No order found, returning generic message');
      
      return {
        type: 'assistant',
        content: `üîç **Suivi de commande**

${trackingResponse.message}

üìû **Pour toute question :**
‚Ä¢ WhatsApp : +221 78 136 27 28
‚Ä¢ Email : contact@viensonseconnait.com

Comment puis-je vous aider autrement ?`,
        choices: [
          'üìû Contacter le support',
          'üõçÔ∏è Passer une nouvelle commande',
          'üè† Page d\'accueil'
        ],
        assistant: {
          name: 'Rose',
          title: 'Assistante d\'achat'
        },
        metadata: {
          nextStep: validateConversationStep('customer_support'),
          externalUrl: {
            type: 'whatsapp',
            url: 'https://wa.me/221781362728',
            description: 'Contacter le support'
          }
        },
        timestamp: new Date().toISOString()
      };
    }

    const order = trackingResponse.order!;
    const statusInfo = this.getDetailedStatusInfo(order.status);
    const paymentStatusText = this.getPaymentStatusText(order.payment_status);

    console.log('‚úÖ [TRACKING] Order details:', {
      id: order.id,
      status: order.status,
      payment_status: order.payment_status,
      total: order.total_amount
    });

    // D√©coder les d√©tails de la commande de mani√®re robuste
    let orderItems: any[] = [];
    try {
      if (order.order_details) {
        if (typeof order.order_details === 'string') {
          orderItems = JSON.parse(order.order_details);
        } else if (Array.isArray(order.order_details)) {
          orderItems = order.order_details;
        } else if (typeof order.order_details === 'object') {
          orderItems = order.order_details.items || [order.order_details];
        }
      }
    } catch (parseError) {
      console.error('‚ùå [TRACKING] Error parsing order details:', parseError);
      orderItems = [];
    }

    const itemsText = orderItems.length > 0 ? 
      orderItems.map((item: any) => {
        const name = item.name || item.productName || 'Produit';
        const quantity = item.quantity || 1;
        return `${name} x${quantity}`;
      }).join(', ') : 
      'Information non disponible';

    // Construire le nom complet du client
    let customerName = 'Client';
    if (order.first_name && order.last_name) {
      customerName = `${order.first_name} ${order.last_name}`;
    } else if (order.customer_name) {
      customerName = order.customer_name;
    } else if (order.first_name) {
      customerName = order.first_name;
    }

    let content = `üîç **Suivi de votre commande #${order.id}**

${statusInfo.emoji} **Statut : ${statusInfo.title}**
${statusInfo.description}

üìã **D√©tails :**
‚Ä¢ Pass√©e le : ${new Date(order.created_at).toLocaleDateString('fr-FR')}
‚Ä¢ Client : ${customerName}
‚Ä¢ Articles : ${itemsText}
‚Ä¢ Total : ${order.total_amount?.toLocaleString() || 'N/A'} FCFA
‚Ä¢ ${paymentStatusText}`;

    // Ajouter l'adresse de livraison si disponible
    if (order.address && order.city) {
      content += `\n\nüìç **Livraison :**\n${order.address}, ${order.city}`;
    }

    // Ajouter le num√©ro de suivi si disponible
    if (order.tracking_number) {
      content += `\nüöö **Suivi : ${order.tracking_number}**`;
      if (order.delivery_company) {
        content += ` (${order.delivery_company})`;
      }
    }

    // Ajouter l'historique si disponible
    if (trackingResponse.statusHistory && trackingResponse.statusHistory.length > 0) {
      content += '\n\nüìÖ **Historique :**';
      // Afficher les 3 derniers √©v√©nements
      trackingResponse.statusHistory.slice(-3).forEach(entry => {
        const date = new Date(entry.date).toLocaleDateString('fr-FR');
        const time = new Date(entry.date).toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
        content += `\n‚Ä¢ ${date} ${time} : ${entry.description}`;
      });
    }

    content += '\n\nüìû **Questions ? Contactez-nous :**\nWhatsApp : +221 78 136 27 28';

    // Choix selon le statut de la commande
    let choices: string[] = [];
    
    if (order.status === 'pending') {
      choices = [
        'üìû WhatsApp (+221 78 136 27 28)',
        'üè† Changer d\'adresse',
        'üîÑ Actualiser le statut'
      ];
    } else if (order.status === 'confirmed') {
      choices = [
        'üìû WhatsApp (+221 78 136 27 28)',
        'üîÑ Actualiser le statut',
        'üì¶ D√©tails de livraison'
      ];
    } else if (order.status === 'cancelled') {
      choices = [
        '‚ùì Pourquoi annul√©e ?',
        'üõçÔ∏è Passer une nouvelle commande',
        'üìû Contacter le support'
      ];
    } else {
      choices = [
        'üìû WhatsApp (+221 78 136 27 28)',
        'üõçÔ∏è Commander autre chose',
        'üìß Envoyer par email'
      ];
    }

    return {
      type: 'assistant',
      content,
      choices,
      assistant: {
        name: 'Rose',
        title: 'Assistante d\'achat'
      },
      metadata: {
        nextStep: validateConversationStep('order_details_shown'),
        orderId: order.id.toString(),
        orderStatus: order.status,
        orderData: {
            id: order.id,
            session_id: order.session_id || sessionId,
            status: validateOrderStatus(order.status), 
            payment_status: order.payment_status,
            total_amount: order.total_amount,
            first_name: order.first_name,        
            last_name: order.last_name,         
            name: customerName,                
            phone: order.phone,                 
            address: order.address,
            city: order.city,
            items: orderItems
            },
        externalUrl: {
          type: 'whatsapp',
          url: 'https://wa.me/221781362728',
          description: 'Contacter pour suivi'
        }
      },
      timestamp: new Date().toISOString()
    };
  }

  // ‚úÖ INFORMATIONS D√âTAILL√âES DU STATUT CORRIG√âES
  private getDetailedStatusInfo(status: OrderStatusType): {
    emoji: string;
    title: string;
    description: string;
  } {
    const statusMap: Record<OrderStatusType, { emoji: string; title: string; description: string }> = {
      'pending': {
        emoji: '‚è≥',
        title: 'En attente',
        description: 'Votre commande est en cours de traitement'
      },
      'confirmed': {
        emoji: '‚úÖ',
        title: 'Confirm√©e',
        description: 'Commande confirm√©e, pr√©paration en cours'
      },
      'cancelled': {
        emoji: '‚ùå',
        title: 'Annul√©e',
        description: 'Commande annul√©e'
      }
    };

    return statusMap[status] || statusMap['pending'];
  }

  // ‚úÖ TEXTE DU STATUT DE PAIEMENT CORRIG√â
  private getPaymentStatusText(paymentStatus: PaymentStatusType): string {
    const statusMap: Record<PaymentStatusType, string> = {
      'completed': '‚úÖ Paiement confirm√©',
      'success': '‚úÖ Paiement confirm√©',
      'pending': '‚è≥ En attente de paiement',
      'processing': 'üîÑ Paiement en cours',
      'failed': '‚ùå √âchec du paiement',
      'cancelled': 'üîÑ Paiement annul√©'
    };

    return statusMap[paymentStatus] || '‚ùì Statut de paiement inconnu';
  }

  // ‚úÖ METTRE √Ä JOUR LE STATUT D'UNE COMMANDE AVEC VALIDATION
  async updateOrderStatus(
    orderId: string, 
    newStatus: string, 
    notes?: string
  ): Promise<boolean> {
    try {
      console.log('üîÑ [TRACKING] Updating order status:', { orderId, newStatus, notes });

      // Validation du statut
      const validatedStatus = validateOrderStatus(newStatus);

      // Mettre √† jour le statut de la commande
      const { error: orderError } = await supabase
        .from('orders')
        .update({
          status: validatedStatus,
          updated_at: new Date().toISOString()
        })
        .eq('id', orderId);

      if (orderError) {
        console.error('‚ùå [TRACKING] Error updating order status:', orderError);
        return false;
      }

      // Ajouter √† l'historique
      const { error: historyError } = await supabase
        .from('delivery_status_history')
        .insert({
          order_id: orderId,
          status: validatedStatus,
          notes: notes || this.getStatusDescription(validatedStatus),
          created_at: new Date().toISOString()
        });

      if (historyError) {
        console.error('‚ùå [TRACKING] Error adding to status history:', historyError);
        // Ne pas faire √©chouer la mise √† jour pour √ßa
      }

      console.log('‚úÖ [TRACKING] Order status updated successfully:', orderId, validatedStatus);
      return true;

    } catch (error) {
      console.error('‚ùå [TRACKING] Error in updateOrderStatus:', error);
      return false;
    }
  }

  // ‚úÖ RECHERCHER UNE COMMANDE PAR NUM√âRO DE T√âL√âPHONE
  async findOrdersByPhone(phone: string): Promise<OrderStatus[]> {
    try {
      console.log('üìû [TRACKING] Finding orders by phone:', phone);

      const { data: orders, error } = await supabase
        .from('orders')
        .select('*')
        .eq('phone', phone)
        .order('created_at', { ascending: false })
        .limit(10);

      if (error) {
        console.error('‚ùå [TRACKING] Error finding orders by phone:', error);
        return [];
      }

      console.log('‚úÖ [TRACKING] Found orders by phone:', orders?.length || 0);
      return (orders || []) as OrderStatus[];

    } catch (error) {
      console.error('‚ùå [TRACKING] Error in findOrdersByPhone:', error);
      return [];
    }
  }

  // ‚úÖ RECHERCHER UNE COMMANDE PAR EMAIL
  async findOrdersByEmail(email: string): Promise<OrderStatus[]> {
    try {
      console.log('üìß [TRACKING] Finding orders by email:', email);

      const { data: orders, error } = await supabase
        .from('orders')
        .select('*')
        .eq('email', email)
        .order('created_at', { ascending: false })
        .limit(10);

      if (error) {
        console.error('‚ùå [TRACKING] Error finding orders by email:', error);
        return [];
      }

      console.log('‚úÖ [TRACKING] Found orders by email:', orders?.length || 0);
      return (orders || []) as OrderStatus[];

    } catch (error) {
      console.error('‚ùå [TRACKING] Error in findOrdersByEmail:', error);
      return [];
    }
  }

  // ‚úÖ STATISTIQUES DE COMMANDES
  async getOrderStats(): Promise<{
    totalOrders: number;
    pendingOrders: number;
    completedOrders: number;
    cancelledOrders: number;
  }> {
    try {
      const { data: orders, error } = await supabase
        .from('orders')
        .select('status');

      if (error || !orders) {
        return {
          totalOrders: 0,
          pendingOrders: 0,
          completedOrders: 0,
          cancelledOrders: 0
        };
      }

      return {
        totalOrders: orders.length,
        pendingOrders: orders.filter(o => o.status === 'pending').length,
        completedOrders: orders.filter(o => o.status === 'confirmed').length,
        cancelledOrders: orders.filter(o => o.status === 'cancelled').length
      };

    } catch (error) {
      console.error('‚ùå [TRACKING] Error getting order stats:', error);
      return {
        totalOrders: 0,
        pendingOrders: 0,
        completedOrders: 0,
        cancelledOrders: 0
      };
    }
  }

  // ‚úÖ CR√âER UN MESSAGE DE TRACKING POUR UN ID SP√âCIFIQUE
  async createTrackingMessageForOrderId(orderId: string): Promise<ChatMessage> {
    console.log('üîç [TRACKING] Creating tracking message for order ID:', orderId);
    
    try {
      const { data: order, error } = await supabase
        .from('orders')
        .select('*')
        .eq('id', parseInt(orderId))
        .single();

      if (error || !order) {
        return {
          type: 'assistant',
          content: `‚ùå **Commande non trouv√©e**

Aucune commande trouv√©e avec l'ID : **${orderId}**

üìû **Contactez-nous si vous pensez qu'il y a une erreur :**
‚Ä¢ WhatsApp : +221 78 136 27 28
‚Ä¢ Email : contact@viensonseconnait.com`,
          choices: [
            'üìû Contacter le support',
            'üîç Chercher avec un autre ID',
            'üè† Page d\'accueil'
          ],
          assistant: {
            name: 'Rose',
            title: 'Assistante d\'achat'
          },
          metadata: {
            nextStep: validateConversationStep('order_not_found')
          },
          timestamp: new Date().toISOString()
        };
      }

      // Utiliser la m√©thode existante avec une session factice
      const fakeSessionId = `order_${orderId}_tracking`;
      return await this.createTrackingMessage(fakeSessionId);

    } catch (error) {
      console.error('‚ùå [TRACKING] Error creating tracking message for order ID:', error);
      return {
        type: 'assistant',
        content: `‚ùå **Erreur technique**

Une erreur est survenue lors de la recherche de votre commande.

üìû **Contactez notre support :**
‚Ä¢ WhatsApp : +221 78 136 27 28`,
        choices: ['üìû Contacter le support'],
        assistant: {
          name: 'Rose',
          title: 'Assistante d\'achat'
        },
        metadata: {
          nextStep: validateConversationStep('tracking_error')
        },
        timestamp: new Date().toISOString()
      };
    }
  }
}